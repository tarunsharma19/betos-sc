"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateEntrypoints = exports.moveCjsFilesAsync = exports.moveCjsFiles = void 0;
const fs_1 = __importDefault(require("fs"));
const promises_1 = __importDefault(require("fs/promises"));
const node_path_1 = require("node:path");
/**
 * Merge a dist-cjs directory into a dist directory
 * @param {string} source - the absolute path to the source directory (Ex. /home/runner/dist-cjs)
 * @param {string} dest - the absolte path to the destination directory (Ex. /home/runner/dist)
 */
function moveCjsFiles(source, dest) {
    const files = fs_1.default.readdirSync(source, { withFileTypes: true });
    for (const file of files) {
        if (file.isDirectory()) {
            fs_1.default.mkdirSync((0, node_path_1.join)(source, file.name), { recursive: true });
            moveCjsFiles((0, node_path_1.join)(source, file.name), (0, node_path_1.join)(dest, file.name));
        }
        else if (file.isFile()) {
            const parsed = (0, node_path_1.parse)(file.name);
            // Ignore anything that's not a .js file
            if (parsed.ext !== ".js") {
                continue;
            }
            // Rewrite any require statements to use .cjs
            const content = fs_1.default.readFileSync((0, node_path_1.join)(source, file.name), "utf8");
            const rewritten = content.replace(/require\("(\..+?).js"\)/g, (_, p1) => {
                return `require("${p1}.cjs")`;
            });
            // Rename the file to .cjs
            const renamed = (0, node_path_1.format)({ name: parsed.name, ext: ".cjs" });
            // console.log(renamed);
            fs_1.default.writeFileSync((0, node_path_1.join)(dest, renamed), rewritten, "utf8");
        }
    }
}
exports.moveCjsFiles = moveCjsFiles;
/**
 * Merge a dist-cjs directory into a dist directory
 * @param {string} source - the absolute path to the source directory (Ex. /home/runner/dist-cjs)
 * @param {string} dest - the absolte path to the destination directory (Ex. /home/runner/dist)
 */
async function moveCjsFilesAsync(source, dest) {
    const files = await promises_1.default.readdir(source, { withFileTypes: true });
    await Promise.all(files.map(async (file) => {
        if (file.isDirectory()) {
            return await moveCjsFiles((0, node_path_1.join)(source, file.name), (0, node_path_1.join)(dest, file.name));
        }
        // its a file
        const parsed = (0, node_path_1.parse)(file.name);
        if (parsed.ext !== ".js") {
            return;
        }
        return await promises_1.default
            .readFile((0, node_path_1.join)(source, file.name), "utf-8")
            .then(async (content) => {
            const rewritten = content.replace(/require\("(\..+?).js"\)/g, (_, p1) => {
                return `require("${p1}.cjs")`;
            });
            const renamed = (0, node_path_1.format)({ name: parsed.name, ext: ".cjs" });
            return await promises_1.default.writeFile((0, node_path_1.join)(dest, renamed), rewritten, "utf-8");
        });
    }));
}
exports.moveCjsFilesAsync = moveCjsFilesAsync;
const updateJsonFile = (relativePath, updateFunction) => {
    const contents = fs_1.default.readFileSync(relativePath, "utf8");
    const res = updateFunction(JSON.parse(contents));
    fs_1.default.writeFileSync(relativePath, JSON.stringify(res, null, 2) + "\n");
};
const generateFiles = (entrypoints, dir) => {
    const files = [...Object.entries(entrypoints), ["index", "index"]].flatMap(([key, value]) => {
        const nrOfDots = key.split("/").length - 1;
        const relativePath = "../".repeat(nrOfDots) || "./";
        const compiledPath = `${relativePath}${dir}/${value}.js`;
        return [
            [
                `${key}.cjs`,
                `module.exports = require('${relativePath}${dir}/${value}.cjs');`,
            ],
            [`${key}.js`, `export * from '${compiledPath}'`],
            [`${key}.d.ts`, `export * from '${compiledPath}'`],
        ];
    });
    return Object.fromEntries(files);
};
/**
 * Generates the package.json and tsconfig entrypoints for an ESM/CJS build
 * @param {string} projectDir - the absolute path to a directory containing a package.json and tsconfig.json
 * @param {string} dir - the name of the output directory (Ex. dist)
 * @param {object} entrypoints - a list of entrypoints to their file location, relative to the projectDir
 * @param {boolean} includeSrcDir - whether to include the src directory in the package.json files
 */
function generateEntrypoints(projectDir, dir, entrypoints, includeSrcDir) {
    // Update tsconfig.json `typedocOptions.entryPoints` field
    updateJsonFile((0, node_path_1.join)(projectDir, "tsconfig.json"), (json) => ({
        ...json,
        typedocOptions: {
            ...json.typedocOptions,
            entryPoints: [...Object.keys(entrypoints)].map((key) => `src/${entrypoints[key]}.ts`),
        },
    }));
    const generatedFiles = generateFiles(entrypoints, dir);
    const filenames = Object.keys(generatedFiles);
    const baseFiles = [`${dir}/`];
    if (includeSrcDir) {
        baseFiles.push("src/");
    }
    // Update package.json `exports` and `files` fields
    updateJsonFile((0, node_path_1.join)(projectDir, "package.json"), (json) => ({
        ...json,
        exports: Object.assign(Object.fromEntries(["index", ...Object.keys(entrypoints)].map((key) => {
            const entryPoint = {
                types: `./${key}.d.ts`,
                import: `./${key}.js`,
                require: `./${key}.cjs`,
            };
            return [key === "index" ? "." : `./${key}`, entryPoint];
        })), { "./package.json": "./package.json" }),
        files: [...baseFiles, "package.json", ...filenames],
    }));
    // Write generated files
    Object.entries(generatedFiles).forEach(([filename, content]) => {
        fs_1.default.mkdirSync((0, node_path_1.dirname)(filename), { recursive: true });
        fs_1.default.writeFileSync(filename, content);
    });
    // Update .gitignore
    fs_1.default.writeFileSync((0, node_path_1.join)(projectDir, ".gitignore"), filenames.join("\n") + "\n");
}
exports.generateEntrypoints = generateEntrypoints;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXNtLXV0aWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2VzbS11dGlscy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSw0Q0FBb0I7QUFDcEIsMkRBQXFDO0FBQ3JDLHlDQUF5RDtBQUV6RDs7OztHQUlHO0FBQ0gsU0FBZ0IsWUFBWSxDQUFDLE1BQU0sRUFBRSxJQUFJO0lBQ3ZDLE1BQU0sS0FBSyxHQUFHLFlBQUUsQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLEVBQUUsYUFBYSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7SUFDOUQsS0FBSyxNQUFNLElBQUksSUFBSSxLQUFLLEVBQUUsQ0FBQztRQUN6QixJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUUsRUFBRSxDQUFDO1lBQ3ZCLFlBQUUsQ0FBQyxTQUFTLENBQUMsSUFBQSxnQkFBSSxFQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztZQUMzRCxZQUFZLENBQUMsSUFBQSxnQkFBSSxFQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsSUFBQSxnQkFBSSxFQUFDLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUMvRCxDQUFDO2FBQU0sSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQztZQUN6QixNQUFNLE1BQU0sR0FBRyxJQUFBLGlCQUFLLEVBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQ2hDLHdDQUF3QztZQUN4QyxJQUFJLE1BQU0sQ0FBQyxHQUFHLEtBQUssS0FBSyxFQUFFLENBQUM7Z0JBQ3pCLFNBQVM7WUFDWCxDQUFDO1lBQ0QsNkNBQTZDO1lBQzdDLE1BQU0sT0FBTyxHQUFHLFlBQUUsQ0FBQyxZQUFZLENBQUMsSUFBQSxnQkFBSSxFQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsSUFBSSxDQUFDLEVB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QUssR0FBRyxFQUFFLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFDMUQsQ0FBQyxDQUFDLENBQ0gsRUFDRCxFQUFFLGdCQUFnQixFQUFFLGdCQUFnQixFQUFFLENBQ3ZDO1FBQ0QsS0FBSyxFQUFFLENBQUMsR0FBRyxTQUFTLEVBQUUsY0FBYyxFQUFFLEdBQUcsU0FBUyxDQUFDO0tBQ3BELENBQUMsQ0FBQyxDQUFDO0lBQ0osd0JBQXdCO0lBQ3hCLE1BQU0sQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxRQUFRLEVBQUUsT0FBTyxDQUFDLEVBQUUsRUFBRTtRQUM3RCxZQUFFLENBQUMsU0FBUyxDQUFDLElBQUEsbUJBQU8sRUFBQyxRQUFRLENBQUMsRUFBRSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBQ3JELFlBQUUsQ0FBQyxhQUFhLENBQUMsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3RDLENBQUMsQ0FBQyxDQUFDO0lBQ0gsb0JBQW9CO0lBQ3BCLFlBQUUsQ0FBQyxhQUFhLENBQUMsSUFBQSxnQkFBSSxFQUFDLFVBQVUsRUFBRSxZQUFZLENBQUMsRUFBRSxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO0FBQ2hGLENBQUM7QUEvQ0Qsa0RBK0NDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZzIGZyb20gXCJmc1wiO1xuaW1wb3J0IGZzUHJvbWlzZXMgZnJvbSBcImZzL3Byb21pc2VzXCI7XG5pbXBvcnQgeyBkaXJuYW1lLCBmb3JtYXQsIGpvaW4sIHBhcnNlIH0gZnJvbSBcIm5vZGU6cGF0aFwiO1xuXG4vKipcbiAqIE1lcmdlIGEgZGlzdC1janMgZGlyZWN0b3J5IGludG8gYSBkaXN0IGRpcmVjdG9yeVxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSAtIHRoZSBhYnNvbHV0ZSBwYXRoIHRvIHRoZSBzb3VyY2UgZGlyZWN0b3J5IChFeC4gL2hvbWUvcnVubmVyL2Rpc3QtY2pzKVxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3QgLSB0aGUgYWJzb2x0ZSBwYXRoIHRvIHRoZSBkZXN0aW5hdGlvbiBkaXJlY3RvcnkgKEV4LiAvaG9tZS9ydW5uZXIvZGlzdClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1vdmVDanNGaWxlcyhzb3VyY2UsIGRlc3QpIHtcbiAgY29uc3QgZmlsZXMgPSBmcy5yZWFkZGlyU3luYyhzb3VyY2UsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KTtcbiAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgaWYgKGZpbGUuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgZnMubWtkaXJTeW5jKGpvaW4oc291cmNlLCBmaWxlLm5hbWUpLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgIG1vdmVDanNGaWxlcyhqb2luKHNvdXJjZSwgZmlsZS5uYW1lKSwgam9pbihkZXN0LCBmaWxlLm5hbWUpKTtcbiAgICB9IGVsc2UgaWYgKGZpbGUuaXNGaWxlKCkpIHtcbiAgICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlKGZpbGUubmFtZSk7XG4gICAgICAvLyBJZ25vcmUgYW55dGhpbmcgdGhhdCdzIG5vdCBhIC5qcyBmaWxlXG4gICAgICBpZiAocGFyc2VkLmV4dCAhPT0gXCIuanNcIikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFJld3JpdGUgYW55IHJlcXVpcmUgc3RhdGVtZW50cyB0byB1c2UgLmNqc1xuICAgICAgY29uc3QgY29udGVudCA9IGZzLnJlYWRGaWxlU3luYyhqb2luKHNvdXJjZSwgZmlsZS5uYW1lKSwgXCJ1dGY4XCIpO1xuICAgICAgY29uc3QgcmV3cml0dGVuID0gY29udGVudC5yZXBsYWNlKC9yZXF1aXJlXFwoXCIoXFwuLis/KS5qc1wiXFwpL2csIChfLCBwMSkgPT4ge1xuICAgICAgICByZXR1cm4gYHJlcXVpcmUoXCIke3AxfS5janNcIilgO1xuICAgICAgfSk7XG4gICAgICAvLyBSZW5hbWUgdGhlIGZpbGUgdG8gLmNqc1xuICAgICAgY29uc3QgcmVuYW1lZCA9IGZvcm1hdCh7IG5hbWU6IHBhcnNlZC5uYW1lLCBleHQ6IFwiLmNqc1wiIH0pO1xuICAgICAgLy8gY29uc29sZS5sb2cocmVuYW1lZCk7XG4gICAgICBmcy53cml0ZUZpbGVTeW5jKGpvaW4oZGVzdCwgcmVuYW1lZCksIHJld3JpdHRlbiwgXCJ1dGY4XCIpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIGEgZGlzdC1janMgZGlyZWN0b3J5IGludG8gYSBkaXN0IGRpcmVjdG9yeVxuICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSAtIHRoZSBhYnNvbHV0ZSBwYXRoIHRvIHRoZSBzb3VyY2UgZGlyZWN0b3J5IChFeC4gL2hvbWUvcnVubmVyL2Rpc3QtY2pzKVxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3QgLSB0aGUgYWJzb2x0ZSBwYXRoIHRvIHRoZSBkZXN0aW5hdGlvbiBkaXJlY3RvcnkgKEV4LiAvaG9tZS9ydW5uZXIvZGlzdClcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1vdmVDanNGaWxlc0FzeW5jKHNvdXJjZSwgZGVzdCkge1xuICBjb25zdCBmaWxlcyA9IGF3YWl0IGZzUHJvbWlzZXMucmVhZGRpcihzb3VyY2UsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9KTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgZmlsZXMubWFwKGFzeW5jIChmaWxlKSA9PiB7XG4gICAgICBpZiAoZmlsZS5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICAgIHJldHVybiBhd2FpdCBtb3ZlQ2pzRmlsZXMoXG4gICAgICAgICAgam9pbihzb3VyY2UsIGZpbGUubmFtZSksXG4gICAgICAgICAgam9pbihkZXN0LCBmaWxlLm5hbWUpXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICAvLyBpdHMgYSBmaWxlXG4gICAgICBjb25zdCBwYXJzZWQgPSBwYXJzZShmaWxlLm5hbWUpO1xuICAgICAgaWYgKHBhcnNlZC5leHQgIT09IFwiLmpzXCIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXdhaXQgZnNQcm9taXNlc1xuICAgICAgICAucmVhZEZpbGUoam9pbihzb3VyY2UsIGZpbGUubmFtZSksIFwidXRmLThcIilcbiAgICAgICAgLnRoZW4oYXN5bmMgKGNvbnRlbnQpID0+IHtcbiAgICAgICAgICBjb25zdCByZXdyaXR0ZW4gPSBjb250ZW50LnJlcGxhY2UoXG4gICAgICAgICAgICAvcmVxdWlyZVxcKFwiKFxcLi4rPykuanNcIlxcKS9nLFxuICAgICAgICAgICAgKF8sIHAxKSA9PiB7XG4gICAgICAgICAgICAgIHJldHVybiBgcmVxdWlyZShcIiR7cDF9LmNqc1wiKWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCByZW5hbWVkID0gZm9ybWF0KHsgbmFtZTogcGFyc2VkLm5hbWUsIGV4dDogXCIuY2pzXCIgfSk7XG4gICAgICAgICAgcmV0dXJuIGF3YWl0IGZzUHJvbWlzZXMud3JpdGVGaWxlKFxuICAgICAgICAgICAgam9pbihkZXN0LCByZW5hbWVkKSxcbiAgICAgICAgICAgIHJld3JpdHRlbixcbiAgICAgICAgICAgIFwidXRmLThcIlxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH0pXG4gICk7XG59XG5cbmNvbnN0IHVwZGF0ZUpzb25GaWxlID0gKHJlbGF0aXZlUGF0aCwgdXBkYXRlRnVuY3Rpb24pID0+IHtcbiAgY29uc3QgY29udGVudHMgPSBmcy5yZWFkRmlsZVN5bmMocmVsYXRpdmVQYXRoLCBcInV0ZjhcIik7XG4gIGNvbnN0IHJlcyA9IHVwZGF0ZUZ1bmN0aW9uKEpTT04ucGFyc2UoY29udGVudHMpKTtcbiAgZnMud3JpdGVGaWxlU3luYyhyZWxhdGl2ZVBhdGgsIEpTT04uc3RyaW5naWZ5KHJlcywgbnVsbCwgMikgKyBcIlxcblwiKTtcbn07XG5cbmNvbnN0IGdlbmVyYXRlRmlsZXMgPSAoZW50cnlwb2ludHMsIGRpcikgPT4ge1xuICBjb25zdCBmaWxlcyA9IFsuLi5PYmplY3QuZW50cmllcyhlbnRyeXBvaW50cyksIFtcImluZGV4XCIsIFwiaW5kZXhcIl1dLmZsYXRNYXAoXG4gICAgKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgY29uc3QgbnJPZkRvdHMgPSBrZXkuc3BsaXQoXCIvXCIpLmxlbmd0aCAtIDE7XG4gICAgICBjb25zdCByZWxhdGl2ZVBhdGggPSBcIi4uL1wiLnJlcGVhdChuck9mRG90cykgfHwgXCIuL1wiO1xuICAgICAgY29uc3QgY29tcGlsZWRQYXRoID0gYCR7cmVsYXRpdmVQYXRofSR7ZGlyfS8ke3ZhbHVlfS5qc2A7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBbXG4gICAgICAgICAgYCR7a2V5fS5janNgLFxuICAgICAgICAgIGBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJyR7cmVsYXRpdmVQYXRofSR7ZGlyfS8ke3ZhbHVlfS5janMnKTtgLFxuICAgICAgICBdLFxuICAgICAgICBbYCR7a2V5fS5qc2AsIGBleHBvcnQgKiBmcm9tICcke2NvbXBpbGVkUGF0aH0nYF0sXG4gICAgICAgIFtgJHtrZXl9LmQudHNgLCBgZXhwb3J0ICogZnJvbSAnJHtjb21waWxlZFBhdGh9J2BdLFxuICAgICAgXTtcbiAgICB9XG4gICk7XG4gIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoZmlsZXMpO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgdGhlIHBhY2thZ2UuanNvbiBhbmQgdHNjb25maWcgZW50cnlwb2ludHMgZm9yIGFuIEVTTS9DSlMgYnVpbGRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9qZWN0RGlyIC0gdGhlIGFic29sdXRlIHBhdGggdG8gYSBkaXJlY3RvcnkgY29udGFpbmluZyBhIHBhY2thZ2UuanNvbiBhbmQgdHNjb25maWcuanNvblxuICogQHBhcmFtIHtzdHJpbmd9IGRpciAtIHRoZSBuYW1lIG9mIHRoZSBvdXRwdXQgZGlyZWN0b3J5IChFeC4gZGlzdClcbiAqIEBwYXJhbSB7b2JqZWN0fSBlbnRyeXBvaW50cyAtIGEgbGlzdCBvZiBlbnRyeXBvaW50cyB0byB0aGVpciBmaWxlIGxvY2F0aW9uLCByZWxhdGl2ZSB0byB0aGUgcHJvamVjdERpclxuICogQHBhcmFtIHtib29sZWFufSBpbmNsdWRlU3JjRGlyIC0gd2hldGhlciB0byBpbmNsdWRlIHRoZSBzcmMgZGlyZWN0b3J5IGluIHRoZSBwYWNrYWdlLmpzb24gZmlsZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlRW50cnlwb2ludHMoXG4gIHByb2plY3REaXIsXG4gIGRpcixcbiAgZW50cnlwb2ludHMsXG4gIGluY2x1ZGVTcmNEaXJcbikge1xuICAvLyBVcGRhdGUgdHNjb25maWcuanNvbiBgdHlwZWRvY09wdGlvbnMuZW50cnlQb2ludHNgIGZpZWxkXG4gIHVwZGF0ZUpzb25GaWxlKGpvaW4ocHJvamVjdERpciwgXCJ0c2NvbmZpZy5qc29uXCIpLCAoanNvbikgPT4gKHtcbiAgICAuLi5qc29uLFxuICAgIHR5cGVkb2NPcHRpb25zOiB7XG4gICAgICAuLi5qc29uLnR5cGVkb2NPcHRpb25zLFxuICAgICAgZW50cnlQb2ludHM6IFsuLi5PYmplY3Qua2V5cyhlbnRyeXBvaW50cyldLm1hcChcbiAgICAgICAgKGtleSkgPT4gYHNyYy8ke2VudHJ5cG9pbnRzW2tleV19LnRzYFxuICAgICAgKSxcbiAgICB9LFxuICB9KSk7XG4gIGNvbnN0IGdlbmVyYXRlZEZpbGVzID0gZ2VuZXJhdGVGaWxlcyhlbnRyeXBvaW50cywgZGlyKTtcbiAgY29uc3QgZmlsZW5hbWVzID0gT2JqZWN0LmtleXMoZ2VuZXJhdGVkRmlsZXMpO1xuICBjb25zdCBiYXNlRmlsZXMgPSBbYCR7ZGlyfS9gXTtcbiAgaWYgKGluY2x1ZGVTcmNEaXIpIHtcbiAgICBiYXNlRmlsZXMucHVzaChcInNyYy9cIik7XG4gIH1cbiAgLy8gVXBkYXRlIHBhY2thZ2UuanNvbiBgZXhwb3J0c2AgYW5kIGBmaWxlc2AgZmllbGRzXG4gIHVwZGF0ZUpzb25GaWxlKGpvaW4ocHJvamVjdERpciwgXCJwYWNrYWdlLmpzb25cIiksIChqc29uKSA9PiAoe1xuICAgIC4uLmpzb24sXG4gICAgZXhwb3J0czogT2JqZWN0LmFzc2lnbihcbiAgICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgICAgW1wiaW5kZXhcIiwgLi4uT2JqZWN0LmtleXMoZW50cnlwb2ludHMpXS5tYXAoKGtleSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGVudHJ5UG9pbnQgPSB7XG4gICAgICAgICAgICB0eXBlczogYC4vJHtrZXl9LmQudHNgLFxuICAgICAgICAgICAgaW1wb3J0OiBgLi8ke2tleX0uanNgLFxuICAgICAgICAgICAgcmVxdWlyZTogYC4vJHtrZXl9LmNqc2AsXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gW2tleSA9PT0gXCJpbmRleFwiID8gXCIuXCIgOiBgLi8ke2tleX1gLCBlbnRyeVBvaW50XTtcbiAgICAgICAgfSlcbiAgICAgICksXG4gICAgICB7IFwiLi9wYWNrYWdlLmpzb25cIjogXCIuL3BhY2thZ2UuanNvblwiIH1cbiAgICApLFxuICAgIGZpbGVzOiBbLi4uYmFzZUZpbGVzLCBcInBhY2thZ2UuanNvblwiLCAuLi5maWxlbmFtZXNdLFxuICB9KSk7XG4gIC8vIFdyaXRlIGdlbmVyYXRlZCBmaWxlc1xuICBPYmplY3QuZW50cmllcyhnZW5lcmF0ZWRGaWxlcykuZm9yRWFjaCgoW2ZpbGVuYW1lLCBjb250ZW50XSkgPT4ge1xuICAgIGZzLm1rZGlyU3luYyhkaXJuYW1lKGZpbGVuYW1lKSwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgZnMud3JpdGVGaWxlU3luYyhmaWxlbmFtZSwgY29udGVudCk7XG4gIH0pO1xuICAvLyBVcGRhdGUgLmdpdGlnbm9yZVxuICBmcy53cml0ZUZpbGVTeW5jKGpvaW4ocHJvamVjdERpciwgXCIuZ2l0aWdub3JlXCIpLCBmaWxlbmFtZXMuam9pbihcIlxcblwiKSArIFwiXFxuXCIpO1xufVxuIl19