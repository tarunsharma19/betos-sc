import type { IOracleJob } from "./protos.js";
import type { TransactionInstruction } from "@solana/web3.js";
/**
 *  The response from the gateway after fetching signatures.
 *  Variables are snake_case for serialization.
 */
export type FeedEvalResponse = {
    /**
     *  Hex encoded oracle pubkey
     */
    oracle_pubkey: string;
    /**
     *  Hex encoded queue pubkey
     */
    queue_pubkey: string;
    /**
     *  Hex encoded oracle signing pubkey
     */
    oracle_signing_pubkey: string;
    /**
     *  Hex encoded feed id
     */
    feed_hash: string;
    /**
     *  Hex encoded blockhash/slothash the response was signed with.
     */
    recent_hash: string;
    /**
     *  Errors encountered while fetching feed value
     */
    failure_error: string;
    /**
     *  Feed values derived
     */
    success_value: string;
    /**
     *  Signed message of the result and blockhash
     */
    msg: string;
    /**
     *  Oracle signature of the result and blockhash
     *
     *  Sha256(success_feed_hashes || results || slothash)
     */
    signature: string;
    recovery_id: number;
    /**
     *  If the feed fetch failed, get other recent successes
     */
    recent_successes_if_failed: Array<FeedEvalResponse>;
    /**
     * Timestamp marking when the result was fetched
     */
    timestamp?: number;
};
/**
 * The response from the gateway after fetching signatures.
 */
export type EVMResult = FeedEvalResponse & {
    /**
     *  The result of the feed evaluation
     */
    result: number;
};
export declare class CrossbarClient {
    readonly crossbarUrl: string;
    readonly verbose: boolean;
    static default(verbose?: boolean): CrossbarClient;
    constructor(crossbarUrl: string, verbose?: boolean);
    /**
     * GET /fetch/:feedHash
     * Fetch data from the crossbar using the provided feedHash
     * @param {string} feedHash - The hash of the feed to fetch data for
     * @returns {Promise<any>} - The data fetched from the crossbar
     */
    fetch(feedHash: string): Promise<any>;
    /**
     * POST /store
     * Store oracle jobs on the crossbar, associated with a queue address
     * @param {string} queueAddress - The address of the queue
     * @param {IOracleJob[]} jobs - The oracle jobs to store
     * @returns {Promise<{ cid: string; feedHash: string; queueHex: string }>} - The stored data information
     */
    store(queueAddress: string, jobs: IOracleJob[]): Promise<{
        cid: string;
        feedHash: string;
        queueHex: string;
    }>;
    /**
     * GET /simulate/:feedHashes
     * Simulate fetching feed results from the crossbar using feed hashes
     * @param {string[]} feedHashes - The hashes of the feeds to simulate
     * @returns {Promise<{ feedHash: string; results: number[] }[]>} - The simulated feed results
     */
    simulateFeeds(feedHashes: string[]): Promise<{
        feedHash: string;
        results: number[];
    }[]>;
    /**
     * GET /updates/solana/:network/:feedpubkeys
     * Fetch updates for Solana network feeds from the crossbar
     * @param {string} network - The Solana network to fetch updates for
     * @param {string[]} feedpubkeys - The public keys of the feeds to fetch updates for
     * @param {number} [numSignatures] - The number of signatures to fetch (optional)
     * @returns {Promise<{ success: boolean; pullIx: TransactionInstruction; responses: { oracle: string; result: number | null; errors: string }[]; lookupTables: string[] }[]>} - The updates for the specified feeds
     */
    fetchSolanaUpdates(network: string, feedpubkeys: string[], numSignatures?: number): Promise<{
        success: boolean;
        pullIx: TransactionInstruction;
        responses: {
            oracle: string;
            result: number | null;
            errors: string;
        }[];
        lookupTables: string[];
    }[]>;
    /**
     * GET /simulate/solana/:network/:feedpubkeys
     * Simulate fetching Solana feed results from the crossbar
     * @param {string} network - The Solana network to simulate
     * @param {string[]} feedpubkeys - The public keys of the feeds to simulate
     * @returns {Promise<{ feed: string; feedHash: string; results: number[] }[]>} - The simulated feed results
     */
    simulateSolanaFeeds(network: string, feedpubkeys: string[]): Promise<{
        feed: string;
        feedHash: string;
        results: number[];
    }[]>;
    /**
     * GET /updates/evm/:chainId/:aggregatorIds
     * Fetch updates for EVM network feeds from the crossbar
     * @param param0 - The chain ID and aggregator IDs to fetch updates for
     * @returns Promise<{ results: EVMResult[]; encoded: string[] }> - The updates for the specified feeds
     */
    fetchEVMResults({ chainId, aggregatorIds, }: {
        chainId: number;
        aggregatorIds: string[];
    }): Promise<{
        results: EVMResult[];
        encoded: string[];
    }>;
    /**
     * GET /simulate/evm/:network/:aggregatorIds
     * Simulate fetching Solana feed results from the crossbar
     * @param {string} network - The Solana network to simulate
     * @param {string[]} aggregatorIds - The public keys of the feeds to simulate
     * @returns {Promise<{ feed: string; feedHash: string; results: number[] }[]>} - The simulated feed results
     */
    simulateEVMFeeds(network: number, aggregatorIds: string[]): Promise<{
        aggregatorId: string;
        feedHash: string;
        results: number[];
    }[]>;
    /**
     * GET /randomness/evm/:chainId/:randomnessId
     * @param param0 - The chain ID and randomness ID to resolve
     */
    resolveEVMRandomness({ chainId, randomnessId, }: {
        chainId: number;
        randomnessId: string;
    }): Promise<{
        encoded: string;
        response: {
            signature: string;
            recovery_id: number;
            value: string;
        };
    }>;
}
//# sourceMappingURL=CrossbarClient.d.ts.map