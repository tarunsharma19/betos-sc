"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CrossbarClient = void 0;
const instructions_js_1 = require("./utils/instructions.cjs");
const string_js_1 = require("./utils/string.cjs");
const axios_1 = __importDefault(require("axios"));
const bs58_1 = __importDefault(require("bs58"));
class CrossbarClient {
    crossbarUrl;
    verbose;
    static default(verbose) {
        return new CrossbarClient("https://crossbar.switchboard.xyz", verbose);
    }
    constructor(crossbarUrl, verbose) {
        this.crossbarUrl = new URL(crossbarUrl).origin;
        this.verbose = !!verbose;
    }
    /**
     * GET /fetch/:feedHash
     * Fetch data from the crossbar using the provided feedHash
     * @param {string} feedHash - The hash of the feed to fetch data for
     * @returns {Promise<any>} - The data fetched from the crossbar
     */
    async fetch(feedHash) {
        try {
            return await axios_1.default
                .get(`${this.crossbarUrl}/fetch/${feedHash}`)
                .then((resp) => resp.data);
        }
        catch (err) {
            if (!axios_1.default.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            // If response is outside of the 200 range, log the status and throw an error.
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar fetch status: ${response.status}`);
        }
    }
    /**
     * POST /store
     * Store oracle jobs on the crossbar, associated with a queue address
     * @param {string} queueAddress - The address of the queue
     * @param {IOracleJob[]} jobs - The oracle jobs to store
     * @returns {Promise<{ cid: string; feedHash: string; queueHex: string }>} - The stored data information
     */
    async store(queueAddress, jobs) {
        try {
            // Try to decode the queueAddress to a Buffer so that we can send it in the expected format,
            // base58, to the Crossbar node.
            const queue = (0, string_js_1.decodeString)(queueAddress);
            if (!queue)
                throw new Error(`Unable to parse queue: ${queueAddress}`);
            return await axios_1.default
                .post(`${this.crossbarUrl}/store`, { queue: bs58_1.default.encode(queue), jobs }, { headers: { "Content-Type": "application/json" } })
                .then((resp) => resp.data);
        }
        catch (err) {
            if (!axios_1.default.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar store response: ${response.status}`);
        }
    }
    /**
     * GET /simulate/:feedHashes
     * Simulate fetching feed results from the crossbar using feed hashes
     * @param {string[]} feedHashes - The hashes of the feeds to simulate
     * @returns {Promise<{ feedHash: string; results: number[] }[]>} - The simulated feed results
     */
    async simulateFeeds(feedHashes) {
        try {
            if (!feedHashes || feedHashes.length === 0)
                throw new Error("At least one feed is required");
            const feedsParam = feedHashes.join(",");
            return await axios_1.default
                .get(`${this.crossbarUrl}/simulate/${feedsParam}`)
                .then((resp) => resp.data);
        }
        catch (err) {
            if (!axios_1.default.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar simulateFeed response: ${response.status}`);
        }
    }
    /**
     * GET /updates/solana/:network/:feedpubkeys
     * Fetch updates for Solana network feeds from the crossbar
     * @param {string} network - The Solana network to fetch updates for
     * @param {string[]} feedpubkeys - The public keys of the feeds to fetch updates for
     * @param {number} [numSignatures] - The number of signatures to fetch (optional)
     * @returns {Promise<{ success: boolean; pullIx: TransactionInstruction; responses: { oracle: string; result: number | null; errors: string }[]; lookupTables: string[] }[]>} - The updates for the specified feeds
     */
    async fetchSolanaUpdates(network, feedpubkeys, numSignatures) {
        try {
            if (!network)
                throw new Error("Network is required");
            if (!feedpubkeys || feedpubkeys.length === 0)
                throw new Error("At least one feed is required");
            const feedsParam = feedpubkeys.join(",");
            const response = await axios_1.default
                .get(`${this.crossbarUrl}/updates/solana/${network}/${feedsParam}`, {
                params: { numSignatures },
            })
                .then((resp) => resp.data);
            // Convert pullIx from hex to TransactionInstruction using IxFromHex
            const updates = response.map((update) => ({
                ...update,
                pullIx: (0, instructions_js_1.IxFromHex)(update.pullIx),
            }));
            return updates;
        }
        catch (err) {
            if (!axios_1.default.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar fetchSolanaUpdates response: ${response.status}`);
        }
    }
    /**
     * GET /simulate/solana/:network/:feedpubkeys
     * Simulate fetching Solana feed results from the crossbar
     * @param {string} network - The Solana network to simulate
     * @param {string[]} feedpubkeys - The public keys of the feeds to simulate
     * @returns {Promise<{ feed: string; feedHash: string; results: number[] }[]>} - The simulated feed results
     */
    async simulateSolanaFeeds(network, feedpubkeys) {
        try {
            if (!network)
                throw new Error("Network is required");
            if (!feedpubkeys || feedpubkeys.length === 0)
                throw new Error("At least one feed is required");
            const feedsParam = feedpubkeys.join(",");
            return await axios_1.default
                .get(`${this.crossbarUrl}/simulate/solana/${network}/${feedsParam}`)
                .then((resp) => resp.data);
        }
        catch (err) {
            if (!axios_1.default.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar simulateSolanaFeeds response: ${response.status}`);
        }
    }
    /**
     * GET /updates/evm/:chainId/:aggregatorIds
     * Fetch updates for EVM network feeds from the crossbar
     * @param param0 - The chain ID and aggregator IDs to fetch updates for
     * @returns Promise<{ results: EVMResult[]; encoded: string[] }> - The updates for the specified feeds
     */
    async fetchEVMResults({ chainId, aggregatorIds, }) {
        try {
            if (!chainId)
                throw new Error("Chain ID is required");
            if (!aggregatorIds || aggregatorIds.length === 0)
                throw new Error("At least one feed is required");
            const feedsParam = aggregatorIds.join(",");
            return await axios_1.default
                .get(`${this.crossbarUrl}/updates/evm/${chainId}/${feedsParam}`)
                .then((resp) => resp.data);
        }
        catch (err) {
            if (!axios_1.default.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar fetchEVMUpdates response: ${response.status}`);
        }
    }
    /**
     * GET /simulate/evm/:network/:aggregatorIds
     * Simulate fetching Solana feed results from the crossbar
     * @param {string} network - The Solana network to simulate
     * @param {string[]} aggregatorIds - The public keys of the feeds to simulate
     * @returns {Promise<{ feed: string; feedHash: string; results: number[] }[]>} - The simulated feed results
     */
    async simulateEVMFeeds(network, aggregatorIds) {
        try {
            if (!network)
                throw new Error("Network is required");
            if (!aggregatorIds || aggregatorIds.length === 0)
                throw new Error("At least one feed is required");
            const feedsParam = aggregatorIds.join(",");
            return await axios_1.default
                .get(`${this.crossbarUrl}/simulate/evm/${network}/${feedsParam}`)
                .then((resp) => resp.data);
        }
        catch (err) {
            if (!axios_1.default.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar simulateEVMFeeds response: ${response.status}`);
        }
    }
    /**
     * GET /randomness/evm/:chainId/:randomnessId
     * @param param0 - The chain ID and randomness ID to resolve
     */
    async resolveEVMRandomness({ chainId, randomnessId, }) {
        try {
            return await axios_1.default
                .get(`${this.crossbarUrl}/randomness/evm/${chainId}/${randomnessId}`)
                .then((resp) => resp.data);
        }
        catch (err) {
            if (!axios_1.default.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar resolveEVMRandomness response: ${response.status}`);
        }
    }
}
exports.CrossbarClient = CrossbarClient;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ3Jvc3NiYXJDbGllbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvQ3Jvc3NiYXJDbGllbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsNkRBQW9EO0FBQ3BELGlEQUFpRDtBQUlqRCxrREFBMEI7QUFDMUIsZ0RBQXdCO0FBb0V4QixNQUFhLGNBQWM7SUFDaEIsV0FBVyxDQUFTO0lBQ3BCLE9BQU8sQ0FBVTtJQUUxQixNQUFNLENBQUMsT0FBTyxDQUFDLE9BQWlCO1FBQzlCLE9BQU8sSUFBSSxjQUFjLENBQUMsa0NBQWtDLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDekUsQ0FBQztJQUVELFlBQVksV0FBbUIsRUFBRSxPQUFpQjtRQUNoRCxJQUFJLENBQUMsV0FBVyxHQUFHLElBQUksR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDLE1BQU0sQ0FBQztRQUMvQyxJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUM7SUFDM0IsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsS0FBSyxDQUFDLEtBQUssQ0FBQyxRQUFnQjtRQUMxQixJQUFJLENBQUM7WUFDSCxPQUFPLE1BQU0sZUFBSztpQkFDZixHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsV0FBVyxVQUFVLFFBQVEsRUFBRSxDQUFDO2lCQUM1QyxJQUFJLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUMvQixDQUFDO1FBQUMsT0FBTyxHQUFHLEVBQUUsQ0FBQztZQUNiLElBQUksQ0FBQyxlQUFLLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQztnQkFBRSxNQUFNLEdBQUcsQ0FBQztZQUV4QyxNQUFNLFFBQVEsR0FBRyxHQUFHLENBQUMsUUFBUSxDQUFDO1lBQzlCLElBQUksQ0FBQyxRQUFRO2dCQUFFLE1BQU0sR0FBRyxDQUFDO1lBRXpCLDhFQUE4RTtZQUM5RSxJQUFJLElBQUksQ0FBQyxPQUFPO2dC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QUNmLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxXQUFXLG1CQUFtQixPQUFPLElBQUksWUFBWSxFQUFFLENBQUM7aUJBQ3BFLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQy9CLENBQUM7UUFBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO1lBQ2IsSUFBSSxDQUFDLGVBQUssQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDO2dCQUFFLE1BQU0sR0FBRyxDQUFDO1lBRXhDLE1BQU0sUUFBUSxHQUFHLEdBQUcsQ0FBQyxRQUFRLENBQUM7WUFDOUIsSUFBSSxDQUFDLFFBQVE7Z0JBQUUsTUFBTSxHQUFHLENBQUM7WUFFekIsSUFBSSxJQUFJLENBQUMsT0FBTztnQkFBRSxPQUFPLENBQUMsS0FBSyxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sS0FBSyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztZQUN4RSxNQUFNLElBQUksS0FBSyxDQUNiLCtDQUErQyxRQUFRLENBQUMsTUFBTSxFQUFFLENBQ2pFLENBQUM7UUFDSixDQUFDO0lBQ0gsQ0FBQztDQUNGO0FBOVJELHdDQThSQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEl4RnJvbUhleCB9IGZyb20gXCIuL3V0aWxzL2luc3RydWN0aW9ucy5qc1wiO1xuaW1wb3J0IHsgZGVjb2RlU3RyaW5nIH0gZnJvbSBcIi4vdXRpbHMvc3RyaW5nLmpzXCI7XG5pbXBvcnQgdHlwZSB7IElPcmFjbGVKb2IgfSBmcm9tIFwiLi9wcm90b3MuanNcIjtcblxuaW1wb3J0IHR5cGUgeyBUcmFuc2FjdGlvbkluc3RydWN0aW9uIH0gZnJvbSBcIkBzb2xhbmEvd2ViMy5qc1wiO1xuaW1wb3J0IGF4aW9zIGZyb20gXCJheGlvc1wiO1xuaW1wb3J0IGJzNTggZnJvbSBcImJzNThcIjtcblxuLyoqXG4gKiAgVGhlIHJlc3BvbnNlIGZyb20gdGhlIGdhdGV3YXkgYWZ0ZXIgZmV0Y2hpbmcgc2lnbmF0dXJlcy5cbiAqICBWYXJpYWJsZXMgYXJlIHNuYWtlX2Nhc2UgZm9yIHNlcmlhbGl6YXRpb24uXG4gKi9cbmV4cG9ydCB0eXBlIEZlZWRFdmFsUmVzcG9uc2UgPSB7XG4gIC8qKlxuICAgKiAgSGV4IGVuY29kZWQgb3JhY2xlIHB1YmtleVxuICAgKi9cbiAgb3JhY2xlX3B1YmtleTogc3RyaW5nO1xuICAvKipcbiAgICogIEhleCBlbmNvZGVkIHF1ZXVlIHB1YmtleVxuICAgKi9cbiAgcXVldWVfcHVia2V5OiBzdHJpbmc7XG4gIC8qKlxuICAgKiAgSGV4IGVuY29kZWQgb3JhY2xlIHNpZ25pbmcgcHVia2V5XG4gICAqL1xuICBvcmFjbGVfc2lnbmluZ19wdWJrZXk6IHN0cmluZztcbiAgLyoqXG4gICAqICBIZXggZW5jb2RlZCBmZWVkIGlkXG4gICAqL1xuICBmZWVkX2hhc2g6IHN0cmluZztcbiAgLyoqXG4gICAqICBIZXggZW5jb2RlZCBibG9ja2hhc2gvc2xvdGhhc2ggdGhlIHJlc3BvbnNlIHdhcyBzaWduZWQgd2l0aC5cbiAgICovXG4gIHJlY2VudF9oYXNoOiBzdHJpbmc7XG4gIC8qKlxuICAgKiAgRXJyb3JzIGVuY291bnRlcmVkIHdoaWxlIGZldGNoaW5nIGZlZWQgdmFsdWVcbiAgICovXG4gIGZhaWx1cmVfZXJyb3I6IHN0cmluZztcbiAgLyoqXG4gICAqICBGZWVkIHZhbHVlcyBkZXJpdmVkXG4gICAqL1xuICBzdWNjZXNzX3ZhbHVlOiBzdHJpbmc7XG4gIC8qKlxuICAgKiAgU2lnbmVkIG1lc3NhZ2Ugb2YgdGhlIHJlc3VsdCBhbmQgYmxvY2toYXNoXG4gICAqL1xuICBtc2c6IHN0cmluZztcbiAgLyoqXG4gICAqICBPcmFjbGUgc2lnbmF0dXJlIG9mIHRoZSByZXN1bHQgYW5kIGJsb2NraGFzaFxuICAgKlxuICAgKiAgU2hhMjU2KHN1Y2Nlc3NfZmVlZF9oYXNoZXMgfHwgcmVzdWx0cyB8fCBzbG90aGFzaClcbiAgICovXG4gIHNpZ25hdHVyZTogc3RyaW5nO1xuICByZWNvdmVyeV9pZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiAgSWYgdGhlIGZlZWQgZmV0Y2ggZmFpbGVkLCBnZXQgb3RoZXIgcmVjZW50IHN1Y2Nlc3Nlc1xuICAgKi9cbiAgcmVjZW50X3N1Y2Nlc3Nlc19pZl9mYWlsZWQ6IEFycmF5PEZlZWRFdmFsUmVzcG9uc2U+O1xuXG4gIC8qKlxuICAgKiBUaW1lc3RhbXAgbWFya2luZyB3aGVuIHRoZSByZXN1bHQgd2FzIGZldGNoZWRcbiAgICovXG4gIHRpbWVzdGFtcD86IG51bWJlcjtcbn07XG5cbi8qKlxuICogVGhlIHJlc3BvbnNlIGZyb20gdGhlIGdhdGV3YXkgYWZ0ZXIgZmV0Y2hpbmcgc2lnbmF0dXJlcy5cbiAqL1xuZXhwb3J0IHR5cGUgRVZNUmVzdWx0ID0gRmVlZEV2YWxSZXNwb25zZSAmIHtcbiAgLyoqXG4gICAqICBUaGUgcmVzdWx0IG9mIHRoZSBmZWVkIGV2YWx1YXRpb25cbiAgICovXG4gIHJlc3VsdDogbnVtYmVyO1xufTtcblxuZXhwb3J0IGNsYXNzIENyb3NzYmFyQ2xpZW50IHtcbiAgcmVhZG9ubHkgY3Jvc3NiYXJVcmw6IHN0cmluZztcbiAgcmVhZG9ubHkgdmVyYm9zZTogYm9vbGVhbjtcblxuICBzdGF0aWMgZGVmYXVsdCh2ZXJib3NlPzogYm9vbGVhbikge1xuICAgIHJldHVybiBuZXcgQ3Jvc3NiYXJDbGllbnQoXCJodHRwczovL2Nyb3NzYmFyLnN3aXRjaGJvYXJkLnh5elwiLCB2ZXJib3NlKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGNyb3NzYmFyVXJsOiBzdHJpbmcsIHZlcmJvc2U/OiBib29sZWFuKSB7XG4gICAgdGhpcy5jcm9zc2JhclVybCA9IG5ldyBVUkwoY3Jvc3NiYXJVcmwpLm9yaWdpbjtcbiAgICB0aGlzLnZlcmJvc2UgPSAhIXZlcmJvc2U7XG4gIH1cblxuICAvKipcbiAgICogR0VUIC9mZXRjaC86ZmVlZEhhc2hcbiAgICogRmV0Y2ggZGF0YSBmcm9tIHRoZSBjcm9zc2JhciB1c2luZyB0aGUgcHJvdmlkZWQgZmVlZEhhc2hcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZlZWRIYXNoIC0gVGhlIGhhc2ggb2YgdGhlIGZlZWQgdG8gZmV0Y2ggZGF0YSBmb3JcbiAgICogQHJldHVybnMge1Byb21pc2U8YW55Pn0gLSBUaGUgZGF0YSBmZXRjaGVkIGZyb20gdGhlIGNyb3NzYmFyXG4gICAqL1xuICBhc3luYyBmZXRjaChmZWVkSGFzaDogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGF4aW9zXG4gICAgICAgIC5nZXQoYCR7dGhpcy5jcm9zc2JhclVybH0vZmV0Y2gvJHtmZWVkSGFzaH1gKVxuICAgICAgICAudGhlbigocmVzcCkgPT4gcmVzcC5kYXRhKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICghYXhpb3MuaXNBeGlvc0Vycm9yKGVycikpIHRocm93IGVycjtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBlcnIucmVzcG9uc2U7XG4gICAgICBpZiAoIXJlc3BvbnNlKSB0aHJvdyBlcnI7XG5cbiAgICAgIC8vIElmIHJlc3BvbnNlIGlzIG91dHNpZGUgb2YgdGhlIDIwMCByYW5nZSwgbG9nIHRoZSBzdGF0dXMgYW5kIHRocm93IGFuIGVycm9yLlxuICAgICAgaWYgKHRoaXMudmVyYm9zZSkgY29uc29sZS5lcnJvcihgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLmRhdGF9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEJhZCBDcm9zc2JhciBmZXRjaCBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBQT1NUIC9zdG9yZVxuICAgKiBTdG9yZSBvcmFjbGUgam9icyBvbiB0aGUgY3Jvc3NiYXIsIGFzc29jaWF0ZWQgd2l0aCBhIHF1ZXVlIGFkZHJlc3NcbiAgICogQHBhcmFtIHtzdHJpbmd9IHF1ZXVlQWRkcmVzcyAtIFRoZSBhZGRyZXNzIG9mIHRoZSBxdWV1ZVxuICAgKiBAcGFyYW0ge0lPcmFjbGVKb2JbXX0gam9icyAtIFRoZSBvcmFjbGUgam9icyB0byBzdG9yZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7IGNpZDogc3RyaW5nOyBmZWVkSGFzaDogc3RyaW5nOyBxdWV1ZUhleDogc3RyaW5nIH0+fSAtIFRoZSBzdG9yZWQgZGF0YSBpbmZvcm1hdGlvblxuICAgKi9cbiAgYXN5bmMgc3RvcmUoXG4gICAgcXVldWVBZGRyZXNzOiBzdHJpbmcsXG4gICAgam9iczogSU9yYWNsZUpvYltdXG4gICk6IFByb21pc2U8eyBjaWQ6IHN0cmluZzsgZmVlZEhhc2g6IHN0cmluZzsgcXVldWVIZXg6IHN0cmluZyB9PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRyeSB0byBkZWNvZGUgdGhlIHF1ZXVlQWRkcmVzcyB0byBhIEJ1ZmZlciBzbyB0aGF0IHdlIGNhbiBzZW5kIGl0IGluIHRoZSBleHBlY3RlZCBmb3JtYXQsXG4gICAgICAvLyBiYXNlNTgsIHRvIHRoZSBDcm9zc2JhciBub2RlLlxuICAgICAgY29uc3QgcXVldWUgPSBkZWNvZGVTdHJpbmcocXVldWVBZGRyZXNzKTtcbiAgICAgIGlmICghcXVldWUpIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHBhcnNlIHF1ZXVlOiAke3F1ZXVlQWRkcmVzc31gKTtcblxuICAgICAgcmV0dXJuIGF3YWl0IGF4aW9zXG4gICAgICAgIC5wb3N0KFxuICAgICAgICAgIGAke3RoaXMuY3Jvc3NiYXJVcmx9L3N0b3JlYCxcbiAgICAgICAgICB7IHF1ZXVlOiBiczU4LmVuY29kZShxdWV1ZSksIGpvYnMgfSxcbiAgICAgICAgICB7IGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSB9XG4gICAgICAgIClcbiAgICAgICAgLnRoZW4oKHJlc3ApID0+IHJlc3AuZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIWF4aW9zLmlzQXhpb3NFcnJvcihlcnIpKSB0aHJvdyBlcnI7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gZXJyLnJlc3BvbnNlO1xuICAgICAgaWYgKCFyZXNwb25zZSkgdGhyb3cgZXJyO1xuXG4gICAgICBpZiAodGhpcy52ZXJib3NlKSBjb25zb2xlLmVycm9yKGAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2UuZGF0YX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQmFkIENyb3NzYmFyIHN0b3JlIHJlc3BvbnNlOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR0VUIC9zaW11bGF0ZS86ZmVlZEhhc2hlc1xuICAgKiBTaW11bGF0ZSBmZXRjaGluZyBmZWVkIHJlc3VsdHMgZnJvbSB0aGUgY3Jvc3NiYXIgdXNpbmcgZmVlZCBoYXNoZXNcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gZmVlZEhhc2hlcyAtIFRoZSBoYXNoZXMgb2YgdGhlIGZlZWRzIHRvIHNpbXVsYXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHsgZmVlZEhhc2g6IHN0cmluZzsgcmVzdWx0czogbnVtYmVyW10gfVtdPn0gLSBUaGUgc2ltdWxhdGVkIGZlZWQgcmVzdWx0c1xuICAgKi9cbiAgYXN5bmMgc2ltdWxhdGVGZWVkcyhcbiAgICBmZWVkSGFzaGVzOiBzdHJpbmdbXVxuICApOiBQcm9taXNlPHsgZmVlZEhhc2g6IHN0cmluZzsgcmVzdWx0czogbnVtYmVyW10gfVtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghZmVlZEhhc2hlcyB8fCBmZWVkSGFzaGVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXQgbGVhc3Qgb25lIGZlZWQgaXMgcmVxdWlyZWRcIik7XG5cbiAgICAgIGNvbnN0IGZlZWRzUGFyYW0gPSBmZWVkSGFzaGVzLmpvaW4oXCIsXCIpO1xuICAgICAgcmV0dXJuIGF3YWl0IGF4aW9zXG4gICAgICAgIC5nZXQoYCR7dGhpcy5jcm9zc2JhclVybH0vc2ltdWxhdGUvJHtmZWVkc1BhcmFtfWApXG4gICAgICAgIC50aGVuKChyZXNwKSA9PiByZXNwLmRhdGEpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCFheGlvcy5pc0F4aW9zRXJyb3IoZXJyKSkgdGhyb3cgZXJyO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGVyci5yZXNwb25zZTtcbiAgICAgIGlmICghcmVzcG9uc2UpIHRocm93IGVycjtcblxuICAgICAgaWYgKHRoaXMudmVyYm9zZSkgY29uc29sZS5lcnJvcihgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLmRhdGF9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEJhZCBDcm9zc2JhciBzaW11bGF0ZUZlZWQgcmVzcG9uc2U6ICR7cmVzcG9uc2Uuc3RhdHVzfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHRVQgL3VwZGF0ZXMvc29sYW5hLzpuZXR3b3JrLzpmZWVkcHVia2V5c1xuICAgKiBGZXRjaCB1cGRhdGVzIGZvciBTb2xhbmEgbmV0d29yayBmZWVkcyBmcm9tIHRoZSBjcm9zc2JhclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIFRoZSBTb2xhbmEgbmV0d29yayB0byBmZXRjaCB1cGRhdGVzIGZvclxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBmZWVkcHVia2V5cyAtIFRoZSBwdWJsaWMga2V5cyBvZiB0aGUgZmVlZHMgdG8gZmV0Y2ggdXBkYXRlcyBmb3JcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtudW1TaWduYXR1cmVzXSAtIFRoZSBudW1iZXIgb2Ygc2lnbmF0dXJlcyB0byBmZXRjaCAob3B0aW9uYWwpXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHsgc3VjY2VzczogYm9vbGVhbjsgcHVsbEl4OiBUcmFuc2FjdGlvbkluc3RydWN0aW9uOyByZXNwb25zZXM6IHsgb3JhY2xlOiBzdHJpbmc7IHJlc3VsdDogbnVtYmVyIHwgbnVsbDsgZXJyb3JzOiBzdHJpbmcgfVtdOyBsb29rdXBUYWJsZXM6IHN0cmluZ1tdIH1bXT59IC0gVGhlIHVwZGF0ZXMgZm9yIHRoZSBzcGVjaWZpZWQgZmVlZHNcbiAgICovXG4gIGFzeW5jIGZldGNoU29sYW5hVXBkYXRlcyhcbiAgICBuZXR3b3JrOiBzdHJpbmcsXG4gICAgZmVlZHB1YmtleXM6IHN0cmluZ1tdLFxuICAgIG51bVNpZ25hdHVyZXM/OiBudW1iZXJcbiAgKTogUHJvbWlzZTxcbiAgICB7XG4gICAgICBzdWNjZXNzOiBib29sZWFuO1xuICAgICAgcHVsbEl4OiBUcmFuc2FjdGlvbkluc3RydWN0aW9uO1xuICAgICAgcmVzcG9uc2VzOiB7IG9yYWNsZTogc3RyaW5nOyByZXN1bHQ6IG51bWJlciB8IG51bGw7IGVycm9yczogc3RyaW5nIH1bXTtcbiAgICAgIGxvb2t1cFRhYmxlczogc3RyaW5nW107XG4gICAgfVtdXG4gID4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW5ldHdvcmspIHRocm93IG5ldyBFcnJvcihcIk5ldHdvcmsgaXMgcmVxdWlyZWRcIik7XG4gICAgICBpZiAoIWZlZWRwdWJrZXlzIHx8IGZlZWRwdWJrZXlzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXQgbGVhc3Qgb25lIGZlZWQgaXMgcmVxdWlyZWRcIik7XG5cbiAgICAgIGNvbnN0IGZlZWRzUGFyYW0gPSBmZWVkcHVia2V5cy5qb2luKFwiLFwiKTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3NcbiAgICAgICAgLmdldChgJHt0aGlzLmNyb3NzYmFyVXJsfS91cGRhdGVzL3NvbGFuYS8ke25ldHdvcmt9LyR7ZmVlZHNQYXJhbX1gLCB7XG4gICAgICAgICAgcGFyYW1zOiB7IG51bVNpZ25hdHVyZXMgfSxcbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oKHJlc3ApID0+IHJlc3AuZGF0YSk7XG5cbiAgICAgIC8vIENvbnZlcnQgcHVsbEl4IGZyb20gaGV4IHRvIFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24gdXNpbmcgSXhGcm9tSGV4XG4gICAgICBjb25zdCB1cGRhdGVzID0gcmVzcG9uc2UubWFwKCh1cGRhdGU6IGFueSkgPT4gKHtcbiAgICAgICAgLi4udXBkYXRlLFxuICAgICAgICBwdWxsSXg6IEl4RnJvbUhleCh1cGRhdGUucHVsbEl4KSxcbiAgICAgIH0pKTtcblxuICAgICAgcmV0dXJuIHVwZGF0ZXM7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIWF4aW9zLmlzQXhpb3NFcnJvcihlcnIpKSB0aHJvdyBlcnI7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gZXJyLnJlc3BvbnNlO1xuICAgICAgaWYgKCFyZXNwb25zZSkgdGhyb3cgZXJyO1xuXG4gICAgICBpZiAodGhpcy52ZXJib3NlKSBjb25zb2xlLmVycm9yKGAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2UuZGF0YX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEJhZCBDcm9zc2JhciBmZXRjaFNvbGFuYVVwZGF0ZXMgcmVzcG9uc2U6ICR7cmVzcG9uc2Uuc3RhdHVzfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdFVCAvc2ltdWxhdGUvc29sYW5hLzpuZXR3b3JrLzpmZWVkcHVia2V5c1xuICAgKiBTaW11bGF0ZSBmZXRjaGluZyBTb2xhbmEgZmVlZCByZXN1bHRzIGZyb20gdGhlIGNyb3NzYmFyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZXR3b3JrIC0gVGhlIFNvbGFuYSBuZXR3b3JrIHRvIHNpbXVsYXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGZlZWRwdWJrZXlzIC0gVGhlIHB1YmxpYyBrZXlzIG9mIHRoZSBmZWVkcyB0byBzaW11bGF0ZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7IGZlZWQ6IHN0cmluZzsgZmVlZEhhc2g6IHN0cmluZzsgcmVzdWx0czogbnVtYmVyW10gfVtdPn0gLSBUaGUgc2ltdWxhdGVkIGZlZWQgcmVzdWx0c1xuICAgKi9cbiAgYXN5bmMgc2ltdWxhdGVTb2xhbmFGZWVkcyhcbiAgICBuZXR3b3JrOiBzdHJpbmcsXG4gICAgZmVlZHB1YmtleXM6IHN0cmluZ1tdXG4gICk6IFByb21pc2U8eyBmZWVkOiBzdHJpbmc7IGZlZWRIYXNoOiBzdHJpbmc7IHJlc3VsdHM6IG51bWJlcltdIH1bXT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIW5ldHdvcmspIHRocm93IG5ldyBFcnJvcihcIk5ldHdvcmsgaXMgcmVxdWlyZWRcIik7XG4gICAgICBpZiAoIWZlZWRwdWJrZXlzIHx8IGZlZWRwdWJrZXlzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXQgbGVhc3Qgb25lIGZlZWQgaXMgcmVxdWlyZWRcIik7XG5cbiAgICAgIGNvbnN0IGZlZWRzUGFyYW0gPSBmZWVkcHVia2V5cy5qb2luKFwiLFwiKTtcbiAgICAgIHJldHVybiBhd2FpdCBheGlvc1xuICAgICAgICAuZ2V0KGAke3RoaXMuY3Jvc3NiYXJVcmx9L3NpbXVsYXRlL3NvbGFuYS8ke25ldHdvcmt9LyR7ZmVlZHNQYXJhbX1gKVxuICAgICAgICAudGhlbigocmVzcCkgPT4gcmVzcC5kYXRhKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICghYXhpb3MuaXNBeGlvc0Vycm9yKGVycikpIHRocm93IGVycjtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBlcnIucmVzcG9uc2U7XG4gICAgICBpZiAoIXJlc3BvbnNlKSB0aHJvdyBlcnI7XG5cbiAgICAgIGlmICh0aGlzLnZlcmJvc2UpIGNvbnNvbGUuZXJyb3IoYCR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5kYXRhfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQmFkIENyb3NzYmFyIHNpbXVsYXRlU29sYW5hRmVlZHMgcmVzcG9uc2U6ICR7cmVzcG9uc2Uuc3RhdHVzfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdFVCAvdXBkYXRlcy9ldm0vOmNoYWluSWQvOmFnZ3JlZ2F0b3JJZHNcbiAgICogRmV0Y2ggdXBkYXRlcyBmb3IgRVZNIG5ldHdvcmsgZmVlZHMgZnJvbSB0aGUgY3Jvc3NiYXJcbiAgICogQHBhcmFtIHBhcmFtMCAtIFRoZSBjaGFpbiBJRCBhbmQgYWdncmVnYXRvciBJRHMgdG8gZmV0Y2ggdXBkYXRlcyBmb3JcbiAgICogQHJldHVybnMgUHJvbWlzZTx7IHJlc3VsdHM6IEVWTVJlc3VsdFtdOyBlbmNvZGVkOiBzdHJpbmdbXSB9PiAtIFRoZSB1cGRhdGVzIGZvciB0aGUgc3BlY2lmaWVkIGZlZWRzXG4gICAqL1xuICBhc3luYyBmZXRjaEVWTVJlc3VsdHMoe1xuICAgIGNoYWluSWQsXG4gICAgYWdncmVnYXRvcklkcyxcbiAgfToge1xuICAgIGNoYWluSWQ6IG51bWJlcjtcbiAgICBhZ2dyZWdhdG9ySWRzOiBzdHJpbmdbXTtcbiAgfSk6IFByb21pc2U8eyByZXN1bHRzOiBFVk1SZXN1bHRbXTsgZW5jb2RlZDogc3RyaW5nW10gfT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIWNoYWluSWQpIHRocm93IG5ldyBFcnJvcihcIkNoYWluIElEIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgaWYgKCFhZ2dyZWdhdG9ySWRzIHx8IGFnZ3JlZ2F0b3JJZHMubGVuZ3RoID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdCBsZWFzdCBvbmUgZmVlZCBpcyByZXF1aXJlZFwiKTtcblxuICAgICAgY29uc3QgZmVlZHNQYXJhbSA9IGFnZ3JlZ2F0b3JJZHMuam9pbihcIixcIik7XG4gICAgICByZXR1cm4gYXdhaXQgYXhpb3NcbiAgICAgICAgLmdldChgJHt0aGlzLmNyb3NzYmFyVXJsfS91cGRhdGVzL2V2bS8ke2NoYWluSWR9LyR7ZmVlZHNQYXJhbX1gKVxuICAgICAgICAudGhlbigocmVzcCkgPT4gcmVzcC5kYXRhKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICghYXhpb3MuaXNBeGlvc0Vycm9yKGVycikpIHRocm93IGVycjtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBlcnIucmVzcG9uc2U7XG4gICAgICBpZiAoIXJlc3BvbnNlKSB0aHJvdyBlcnI7XG5cbiAgICAgIGlmICh0aGlzLnZlcmJvc2UpIGNvbnNvbGUuZXJyb3IoYCR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5kYXRhfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQmFkIENyb3NzYmFyIGZldGNoRVZNVXBkYXRlcyByZXNwb25zZTogJHtyZXNwb25zZS5zdGF0dXN9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR0VUIC9zaW11bGF0ZS9ldm0vOm5ldHdvcmsvOmFnZ3JlZ2F0b3JJZHNcbiAgICogU2ltdWxhdGUgZmV0Y2hpbmcgU29sYW5hIGZlZWQgcmVzdWx0cyBmcm9tIHRoZSBjcm9zc2JhclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIFRoZSBTb2xhbmEgbmV0d29yayB0byBzaW11bGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBhZ2dyZWdhdG9ySWRzIC0gVGhlIHB1YmxpYyBrZXlzIG9mIHRoZSBmZWVkcyB0byBzaW11bGF0ZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7IGZlZWQ6IHN0cmluZzsgZmVlZEhhc2g6IHN0cmluZzsgcmVzdWx0czogbnVtYmVyW10gfVtdPn0gLSBUaGUgc2ltdWxhdGVkIGZlZWQgcmVzdWx0c1xuICAgKi9cbiAgYXN5bmMgc2ltdWxhdGVFVk1GZWVkcyhcbiAgICBuZXR3b3JrOiBudW1iZXIsXG4gICAgYWdncmVnYXRvcklkczogc3RyaW5nW11cbiAgKTogUHJvbWlzZTx7IGFnZ3JlZ2F0b3JJZDogc3RyaW5nOyBmZWVkSGFzaDogc3RyaW5nOyByZXN1bHRzOiBudW1iZXJbXSB9W10+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFuZXR3b3JrKSB0aHJvdyBuZXcgRXJyb3IoXCJOZXR3b3JrIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgaWYgKCFhZ2dyZWdhdG9ySWRzIHx8IGFnZ3JlZ2F0b3JJZHMubGVuZ3RoID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBdCBsZWFzdCBvbmUgZmVlZCBpcyByZXF1aXJlZFwiKTtcblxuICAgICAgY29uc3QgZmVlZHNQYXJhbSA9IGFnZ3JlZ2F0b3JJZHMuam9pbihcIixcIik7XG4gICAgICByZXR1cm4gYXdhaXQgYXhpb3NcbiAgICAgICAgLmdldChgJHt0aGlzLmNyb3NzYmFyVXJsfS9zaW11bGF0ZS9ldm0vJHtuZXR3b3JrfS8ke2ZlZWRzUGFyYW19YClcbiAgICAgICAgLnRoZW4oKHJlc3ApID0+IHJlc3AuZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIWF4aW9zLmlzQXhpb3NFcnJvcihlcnIpKSB0aHJvdyBlcnI7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gZXJyLnJlc3BvbnNlO1xuICAgICAgaWYgKCFyZXNwb25zZSkgdGhyb3cgZXJyO1xuXG4gICAgICBpZiAodGhpcy52ZXJib3NlKSBjb25zb2xlLmVycm9yKGAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2UuZGF0YX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEJhZCBDcm9zc2JhciBzaW11bGF0ZUVWTUZlZWRzIHJlc3BvbnNlOiAke3Jlc3BvbnNlLnN0YXR1c31gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHRVQgL3JhbmRvbW5lc3MvZXZtLzpjaGFpbklkLzpyYW5kb21uZXNzSWRcbiAgICogQHBhcmFtIHBhcmFtMCAtIFRoZSBjaGFpbiBJRCBhbmQgcmFuZG9tbmVzcyBJRCB0byByZXNvbHZlXG4gICAqL1xuICBhc3luYyByZXNvbHZlRVZNUmFuZG9tbmVzcyh7XG4gICAgY2hhaW5JZCxcbiAgICByYW5kb21uZXNzSWQsXG4gIH06IHtcbiAgICBjaGFpbklkOiBudW1iZXI7XG4gICAgcmFuZG9tbmVzc0lkOiBzdHJpbmc7XG4gIH0pOiBQcm9taXNlPHtcbiAgICBlbmNvZGVkOiBzdHJpbmc7XG4gICAgcmVzcG9uc2U6IHtcbiAgICAgIHNpZ25hdHVyZTogc3RyaW5nO1xuICAgICAgcmVjb3ZlcnlfaWQ6IG51bWJlcjtcbiAgICAgIHZhbHVlOiBzdHJpbmc7XG4gICAgfTtcbiAgfT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgYXhpb3NcbiAgICAgICAgLmdldChgJHt0aGlzLmNyb3NzYmFyVXJsfS9yYW5kb21uZXNzL2V2bS8ke2NoYWluSWR9LyR7cmFuZG9tbmVzc0lkfWApXG4gICAgICAgIC50aGVuKChyZXNwKSA9PiByZXNwLmRhdGEpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCFheGlvcy5pc0F4aW9zRXJyb3IoZXJyKSkgdGhyb3cgZXJyO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGVyci5yZXNwb25zZTtcbiAgICAgIGlmICghcmVzcG9uc2UpIHRocm93IGVycjtcblxuICAgICAgaWYgKHRoaXMudmVyYm9zZSkgY29uc29sZS5lcnJvcihgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLmRhdGF9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBCYWQgQ3Jvc3NiYXIgcmVzb2x2ZUVWTVJhbmRvbW5lc3MgcmVzcG9uc2U6ICR7cmVzcG9uc2Uuc3RhdHVzfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG4iXX0=