"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isSwitchboardLabsQueue = exports.getSupportedNetwork = exports.getSupportedChain = exports.validateSupportedChain = void 0;
const index_js_1 = __importDefault(require("../networks/index.cjs"));
const index_js_2 = require("../networks/index.cjs");
const types_js_1 = require("../networks/types.cjs");
/**
 * Type assertion for whether the given chain is supported. Throws an error if Switchboard is not deployed on the target chain.
 * @param _chain - the target chain
 */
const validateSupportedChain = (_chain) => {
    if (!(0, index_js_2.isSupportedChain)(_chain)) {
        const supportedChainsString = `'${types_js_1.SWITCHBOARD_CHAINS.slice(0, -1).join("', '")}', or '${types_js_1.SWITCHBOARD_CHAINS[types_js_1.SWITCHBOARD_CHAINS.length - 1]}'`;
        throw new Error(`chain ${_chain} is not supported, the currently supported chains are ${supportedChainsString}`);
    }
    return _chain;
};
exports.validateSupportedChain = validateSupportedChain;
/**
 * Return the chain config for a Switchboard implementation. Throws an error if Switchboard is not deployed on the target chain.
 * @param _chain - the target chain
 */
const getSupportedChain = (_chain) => {
    const chain = (0, exports.validateSupportedChain)(_chain);
    return index_js_1.default[chain];
};
exports.getSupportedChain = getSupportedChain;
/**
 * Return the network config for a Switchboard deployment. Throws an error if Switchboard is not deployed on the target chain.
 * @param _chain - the target chain
 * @param _network - the target network
 */
const getSupportedNetwork = (_chain, _network) => {
    const chain = (0, exports.validateSupportedChain)(_chain);
    const chainConfig = index_js_1.default[chain];
    if (chain === "solana") {
        if (_network !== "mainnet" && _network !== "devnet") {
            throw new Error(`UnsupportedNetwork: network needs to be 'mainnet' or 'devnet'`);
        }
        return chainConfig[_network];
    }
    if (chain === "starknet") {
        const supported = new Set(["goerli", "sepolia", "mainnet"]);
        if (supported.has(_network)) {
            const starknetNetwork = _network;
            return chainConfig[starknetNetwork];
        }
        throw new Error(`UnsupportedNetwork: '${_network}'`);
    }
    if (_network !== "mainnet" &&
        _network !== "testnet" &&
        _network !== "sepolia") {
        throw new Error(`UnsupportedNetwork: network needs to be 'mainnet', 'sepolia', or 'testnet'`);
    }
    return chainConfig[_network];
};
exports.getSupportedNetwork = getSupportedNetwork;
/**
 * Determines whether a given chain, network, and queue is managed by SwitchboardLabs
 * @param _chain - the target chain of the queue (Ex. solana or arbitrum)
 * @param _network - the target network of the queue (Ex. mainnet or testnet)
 * @param _queue - the address of the queue
 * @returns a boolean indicating whether the queue is operated by SwitchboardLabs
 */
const isSwitchboardLabsQueue = (_chain, _network, _queue) => {
    try {
        const networkConfig = (0, exports.getSupportedNetwork)(_chain, _network);
        for (const queue of networkConfig.queues) {
            if (queue.address === _queue) {
                return true;
            }
        }
    }
    catch { }
    return false;
};
exports.isSwitchboardLabsQueue = isSwitchboardLabsQueue;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmV0d29ya3MuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdXRpbHMvbmV0d29ya3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsb0VBQXdEO0FBQ3hELG1EQUF3RDtBQVN4RCxtREFBMEQ7QUFFMUQ7OztHQUdHO0FBQ0ksTUFBTSxzQkFBc0IsR0FBRyxDQUFDLE1BQWMsRUFBYSxFQUFFO0lBQ2xFLElBQUksQ0FBQyxJQUFBLDJCQUFnQixFQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUM7UUFDOUIsTUFBTSxxQkFBcUIsR0FBRyxJQUFJLDZCQUFrQixDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQ3BFLE1BQU0sQ0FDUCxVQUFVLDZCQUFrQixDQUFDLDZCQUFrQixDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDO1FBQ2hFLE1BQU0sSUFBSSxLQUFLLENBQ2IsU0FBUyxNQUFNLHlEQUF5RCxxQkFBcUIsRUFBRSxDQUNoRyxDQUFDO0lBQ0osQ0FBQztJQUNELE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUMsQ0FBQztBQVZXLFFBQUEsc0JBQXNCLDBCQVVqQztBQUVGOzs7R0FHRztBQUNJLE1BQU0saUJBQWlCLEdBQUcsQ0FBQyxNQUFjLEVBQWUsRUFBRTtJQUMvRCxNQUFNLEtBQUssR0FBYyxJQUFBLDhCQUFzQixFQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3hELE9BQU8sa0JBQW9CLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDckMsQ0FBQyxDQUFDO0FBSFcsUUFBQSxpQkFBaUIscUJBRzVCO0FBRUY7Ozs7R0FJRztBQUNJLE1BQU0sbUJBQW1CLEdBQUcsQ0FDakMsTUFBYyxFQUNkLFFBQWdCLEVBQ0ssRUFBRTtJQUN2QixNQUFNLEtBQUssR0FBYyxJQUFBLDhCQUFzQixFQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3hELE1BQU0sV0FBVyxHQUFnQixrQkFBb0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUU3RCxJQUFJLEtBQUssS0FBSyxRQUFRLEVBQUUsQ0FBQztRQUN2QixJQUFJLFFBQVEsS0FBSyxTQUFTLElBQUksUUFBUSxLQUFLLFFBQVEsRUFBRSxDQUFDO1lBQ3BELE1BQU0sSUFBSSxLQUFLLENBQ2IsK0RBQStELENBQ2hFLENBQUM7UUFDSixDQUFDO1FBQ0QsT0FBUSxXQUE2QixDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ2xELENBQUM7SUFFRCxJQUFJLEtBQUssS0FBSyxVQUFVLEVBQUUsQ0FBQztRQUN6QixNQUFNLFNBQVMsR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDLFFBQVEsRUFBRSxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQztRQUM1RCxJQUFJLFNBQVMsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQztZQUM1QixNQUFNLGVBQWUsR0FBRyxRQUFpQyxDQUFDO1lBQzFELE9BQVEsV0FBK0IsQ0FBQyxlQUFlLENBQUMsQ0FBQztRQUMzRCxDQUFDO1FBQ0QsTUFBTSxJQUFJLEtBQUssQ0FBQyx3QkFBd0IsUUFBUSxHQUFHLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQsSUFDRSxRQUFRLEtBQUssU0FBUztRQUN0QixRQUFRLEtBQUssU0FBUztRQUN0QixRQUFRLEtBQUssU0FBUyxFQUN0QixDQUFDO1FBQ0QsTUFBTSxJQUFJLEtBQUssQ0FDYiw0RUFBNEUsQ0FDN0UsQ0FBQztJQUNKLENBQUM7SUFFRCxPQUFRLFdBQTRCLENBQUMsUUFBUSxDQUFFLENBQUM7QUFDbEQsQ0FBQyxDQUFDO0FBcENXLFFBQUEsbUJBQW1CLHVCQW9DOUI7QUFFRjs7Ozs7O0dBTUc7QUFDSSxNQUFNLHNCQUFzQixHQUFHLENBQ3BDLE1BQWMsRUFDZCxRQUFnQixFQUNoQixNQUFjLEVBQ0wsRUFBRTtJQUNYLElBQUksQ0FBQztRQUNILE1BQU0sYUFBYSxHQUFHLElBQUEsMkJBQW1CLEVBQUMsTUFBTSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQzVELEtBQUssTUFBTSxLQUFLLElBQUksYUFBYSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ3pDLElBQUksS0FBSyxDQUFDLE9BQU8sS0FBSyxNQUFNLEVBQUUsQ0FBQztnQkFDN0IsT0FBTyxJQUFJLENBQUM7WUFDZCxDQUFDO1FBQ0gsQ0FBQztJQUNILENBQUM7SUFBQyxNQUFNLENBQUMsQ0FBQSxDQUFDO0lBQ1YsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDLENBQUM7QUFkVyxRQUFBLHNCQUFzQiwwQkFjakMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgU1dJVENIQk9BUkRfTkVUV09SS1MgZnJvbSBcIi4uL25ldHdvcmtzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBpc1N1cHBvcnRlZENoYWluIH0gZnJvbSBcIi4uL25ldHdvcmtzL2luZGV4LmpzXCI7XG5pbXBvcnQgdHlwZSB7XG4gIENoYWluQ29uZmlnLFxuICBDaGFpblR5cGUsXG4gIElDaGFpbkNvbmZpZyxcbiAgSUNoYWluTmV0d29ya0NvbmZpZyxcbiAgSVNvbGFuYUNvbmZpZyxcbiAgSVN0YXJrbmV0Q29uZmlnLFxufSBmcm9tIFwiLi4vbmV0d29ya3MvdHlwZXMuanNcIjtcbmltcG9ydCB7IFNXSVRDSEJPQVJEX0NIQUlOUyB9IGZyb20gXCIuLi9uZXR3b3Jrcy90eXBlcy5qc1wiO1xuXG4vKipcbiAqIFR5cGUgYXNzZXJ0aW9uIGZvciB3aGV0aGVyIHRoZSBnaXZlbiBjaGFpbiBpcyBzdXBwb3J0ZWQuIFRocm93cyBhbiBlcnJvciBpZiBTd2l0Y2hib2FyZCBpcyBub3QgZGVwbG95ZWQgb24gdGhlIHRhcmdldCBjaGFpbi5cbiAqIEBwYXJhbSBfY2hhaW4gLSB0aGUgdGFyZ2V0IGNoYWluXG4gKi9cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZVN1cHBvcnRlZENoYWluID0gKF9jaGFpbjogc3RyaW5nKTogQ2hhaW5UeXBlID0+IHtcbiAgaWYgKCFpc1N1cHBvcnRlZENoYWluKF9jaGFpbikpIHtcbiAgICBjb25zdCBzdXBwb3J0ZWRDaGFpbnNTdHJpbmcgPSBgJyR7U1dJVENIQk9BUkRfQ0hBSU5TLnNsaWNlKDAsIC0xKS5qb2luKFxuICAgICAgXCInLCAnXCJcbiAgICApfScsIG9yICcke1NXSVRDSEJPQVJEX0NIQUlOU1tTV0lUQ0hCT0FSRF9DSEFJTlMubGVuZ3RoIC0gMV19J2A7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgYGNoYWluICR7X2NoYWlufSBpcyBub3Qgc3VwcG9ydGVkLCB0aGUgY3VycmVudGx5IHN1cHBvcnRlZCBjaGFpbnMgYXJlICR7c3VwcG9ydGVkQ2hhaW5zU3RyaW5nfWBcbiAgICApO1xuICB9XG4gIHJldHVybiBfY2hhaW47XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgY2hhaW4gY29uZmlnIGZvciBhIFN3aXRjaGJvYXJkIGltcGxlbWVudGF0aW9uLiBUaHJvd3MgYW4gZXJyb3IgaWYgU3dpdGNoYm9hcmQgaXMgbm90IGRlcGxveWVkIG9uIHRoZSB0YXJnZXQgY2hhaW4uXG4gKiBAcGFyYW0gX2NoYWluIC0gdGhlIHRhcmdldCBjaGFpblxuICovXG5leHBvcnQgY29uc3QgZ2V0U3VwcG9ydGVkQ2hhaW4gPSAoX2NoYWluOiBzdHJpbmcpOiBDaGFpbkNvbmZpZyA9PiB7XG4gIGNvbnN0IGNoYWluOiBDaGFpblR5cGUgPSB2YWxpZGF0ZVN1cHBvcnRlZENoYWluKF9jaGFpbik7XG4gIHJldHVybiBTV0lUQ0hCT0FSRF9ORVRXT1JLU1tjaGFpbl07XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbmV0d29yayBjb25maWcgZm9yIGEgU3dpdGNoYm9hcmQgZGVwbG95bWVudC4gVGhyb3dzIGFuIGVycm9yIGlmIFN3aXRjaGJvYXJkIGlzIG5vdCBkZXBsb3llZCBvbiB0aGUgdGFyZ2V0IGNoYWluLlxuICogQHBhcmFtIF9jaGFpbiAtIHRoZSB0YXJnZXQgY2hhaW5cbiAqIEBwYXJhbSBfbmV0d29yayAtIHRoZSB0YXJnZXQgbmV0d29ya1xuICovXG5leHBvcnQgY29uc3QgZ2V0U3VwcG9ydGVkTmV0d29yayA9IChcbiAgX2NoYWluOiBzdHJpbmcsXG4gIF9uZXR3b3JrOiBzdHJpbmdcbik6IElDaGFpbk5ldHdvcmtDb25maWcgPT4ge1xuICBjb25zdCBjaGFpbjogQ2hhaW5UeXBlID0gdmFsaWRhdGVTdXBwb3J0ZWRDaGFpbihfY2hhaW4pO1xuICBjb25zdCBjaGFpbkNvbmZpZzogQ2hhaW5Db25maWcgPSBTV0lUQ0hCT0FSRF9ORVRXT1JLU1tjaGFpbl07XG5cbiAgaWYgKGNoYWluID09PSBcInNvbGFuYVwiKSB7XG4gICAgaWYgKF9uZXR3b3JrICE9PSBcIm1haW5uZXRcIiAmJiBfbmV0d29yayAhPT0gXCJkZXZuZXRcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVW5zdXBwb3J0ZWROZXR3b3JrOiBuZXR3b3JrIG5lZWRzIHRvIGJlICdtYWlubmV0JyBvciAnZGV2bmV0J2BcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiAoY2hhaW5Db25maWcgYXMgSVNvbGFuYUNvbmZpZylbX25ldHdvcmtdO1xuICB9XG5cbiAgaWYgKGNoYWluID09PSBcInN0YXJrbmV0XCIpIHtcbiAgICBjb25zdCBzdXBwb3J0ZWQgPSBuZXcgU2V0KFtcImdvZXJsaVwiLCBcInNlcG9saWFcIiwgXCJtYWlubmV0XCJdKTtcbiAgICBpZiAoc3VwcG9ydGVkLmhhcyhfbmV0d29yaykpIHtcbiAgICAgIGNvbnN0IHN0YXJrbmV0TmV0d29yayA9IF9uZXR3b3JrIGFzIGtleW9mIElTdGFya25ldENvbmZpZztcbiAgICAgIHJldHVybiAoY2hhaW5Db25maWcgYXMgSVN0YXJrbmV0Q29uZmlnKVtzdGFya25ldE5ldHdvcmtdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkTmV0d29yazogJyR7X25ldHdvcmt9J2ApO1xuICB9XG5cbiAgaWYgKFxuICAgIF9uZXR3b3JrICE9PSBcIm1haW5uZXRcIiAmJlxuICAgIF9uZXR3b3JrICE9PSBcInRlc3RuZXRcIiAmJlxuICAgIF9uZXR3b3JrICE9PSBcInNlcG9saWFcIlxuICApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVW5zdXBwb3J0ZWROZXR3b3JrOiBuZXR3b3JrIG5lZWRzIHRvIGJlICdtYWlubmV0JywgJ3NlcG9saWEnLCBvciAndGVzdG5ldCdgXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiAoY2hhaW5Db25maWcgYXMgSUNoYWluQ29uZmlnKVtfbmV0d29ya10hO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBnaXZlbiBjaGFpbiwgbmV0d29yaywgYW5kIHF1ZXVlIGlzIG1hbmFnZWQgYnkgU3dpdGNoYm9hcmRMYWJzXG4gKiBAcGFyYW0gX2NoYWluIC0gdGhlIHRhcmdldCBjaGFpbiBvZiB0aGUgcXVldWUgKEV4LiBzb2xhbmEgb3IgYXJiaXRydW0pXG4gKiBAcGFyYW0gX25ldHdvcmsgLSB0aGUgdGFyZ2V0IG5ldHdvcmsgb2YgdGhlIHF1ZXVlIChFeC4gbWFpbm5ldCBvciB0ZXN0bmV0KVxuICogQHBhcmFtIF9xdWV1ZSAtIHRoZSBhZGRyZXNzIG9mIHRoZSBxdWV1ZVxuICogQHJldHVybnMgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgcXVldWUgaXMgb3BlcmF0ZWQgYnkgU3dpdGNoYm9hcmRMYWJzXG4gKi9cbmV4cG9ydCBjb25zdCBpc1N3aXRjaGJvYXJkTGFic1F1ZXVlID0gKFxuICBfY2hhaW46IHN0cmluZyxcbiAgX25ldHdvcms6IHN0cmluZyxcbiAgX3F1ZXVlOiBzdHJpbmdcbik6IGJvb2xlYW4gPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IG5ldHdvcmtDb25maWcgPSBnZXRTdXBwb3J0ZWROZXR3b3JrKF9jaGFpbiwgX25ldHdvcmspO1xuICAgIGZvciAoY29uc3QgcXVldWUgb2YgbmV0d29ya0NvbmZpZy5xdWV1ZXMpIHtcbiAgICAgIGlmIChxdWV1ZS5hZGRyZXNzID09PSBfcXVldWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIHt9XG4gIHJldHVybiBmYWxzZTtcbn07XG4iXX0=