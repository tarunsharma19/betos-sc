import { IxFromHex } from "./utils/instructions.js";
import { decodeString } from "./utils/string.js";
import axios from "axios";
import bs58 from "bs58";
export class CrossbarClient {
    crossbarUrl;
    verbose;
    static default(verbose) {
        return new CrossbarClient("https://crossbar.switchboard.xyz", verbose);
    }
    constructor(crossbarUrl, verbose) {
        this.crossbarUrl = new URL(crossbarUrl).origin;
        this.verbose = !!verbose;
    }
    /**
     * GET /fetch/:feedHash
     * Fetch data from the crossbar using the provided feedHash
     * @param {string} feedHash - The hash of the feed to fetch data for
     * @returns {Promise<any>} - The data fetched from the crossbar
     */
    async fetch(feedHash) {
        try {
            return await axios
                .get(`${this.crossbarUrl}/fetch/${feedHash}`)
                .then((resp) => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            // If response is outside of the 200 range, log the status and throw an error.
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar fetch status: ${response.status}`);
        }
    }
    /**
     * POST /store
     * Store oracle jobs on the crossbar, associated with a queue address
     * @param {string} queueAddress - The address of the queue
     * @param {IOracleJob[]} jobs - The oracle jobs to store
     * @returns {Promise<{ cid: string; feedHash: string; queueHex: string }>} - The stored data information
     */
    async store(queueAddress, jobs) {
        try {
            // Try to decode the queueAddress to a Buffer so that we can send it in the expected format,
            // base58, to the Crossbar node.
            const queue = decodeString(queueAddress);
            if (!queue)
                throw new Error(`Unable to parse queue: ${queueAddress}`);
            return await axios
                .post(`${this.crossbarUrl}/store`, { queue: bs58.encode(queue), jobs }, { headers: { "Content-Type": "application/json" } })
                .then((resp) => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar store response: ${response.status}`);
        }
    }
    /**
     * GET /simulate/:feedHashes
     * Simulate fetching feed results from the crossbar using feed hashes
     * @param {string[]} feedHashes - The hashes of the feeds to simulate
     * @returns {Promise<{ feedHash: string; results: number[] }[]>} - The simulated feed results
     */
    async simulateFeeds(feedHashes) {
        try {
            if (!feedHashes || feedHashes.length === 0)
                throw new Error("At least one feed is required");
            const feedsParam = feedHashes.join(",");
            return await axios
                .get(`${this.crossbarUrl}/simulate/${feedsParam}`)
                .then((resp) => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar simulateFeed response: ${response.status}`);
        }
    }
    /**
     * GET /updates/solana/:network/:feedpubkeys
     * Fetch updates for Solana network feeds from the crossbar
     * @param {string} network - The Solana network to fetch updates for
     * @param {string[]} feedpubkeys - The public keys of the feeds to fetch updates for
     * @param {number} [numSignatures] - The number of signatures to fetch (optional)
     * @returns {Promise<{ success: boolean; pullIx: TransactionInstruction; responses: { oracle: string; result: number | null; errors: string }[]; lookupTables: string[] }[]>} - The updates for the specified feeds
     */
    async fetchSolanaUpdates(network, feedpubkeys, numSignatures) {
        try {
            if (!network)
                throw new Error("Network is required");
            if (!feedpubkeys || feedpubkeys.length === 0)
                throw new Error("At least one feed is required");
            const feedsParam = feedpubkeys.join(",");
            const response = await axios
                .get(`${this.crossbarUrl}/updates/solana/${network}/${feedsParam}`, {
                params: { numSignatures },
            })
                .then((resp) => resp.data);
            // Convert pullIx from hex to TransactionInstruction using IxFromHex
            const updates = response.map((update) => ({
                ...update,
                pullIx: IxFromHex(update.pullIx),
            }));
            return updates;
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar fetchSolanaUpdates response: ${response.status}`);
        }
    }
    /**
     * GET /simulate/solana/:network/:feedpubkeys
     * Simulate fetching Solana feed results from the crossbar
     * @param {string} network - The Solana network to simulate
     * @param {string[]} feedpubkeys - The public keys of the feeds to simulate
     * @returns {Promise<{ feed: string; feedHash: string; results: number[] }[]>} - The simulated feed results
     */
    async simulateSolanaFeeds(network, feedpubkeys) {
        try {
            if (!network)
                throw new Error("Network is required");
            if (!feedpubkeys || feedpubkeys.length === 0)
                throw new Error("At least one feed is required");
            const feedsParam = feedpubkeys.join(",");
            return await axios
                .get(`${this.crossbarUrl}/simulate/solana/${network}/${feedsParam}`)
                .then((resp) => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar simulateSolanaFeeds response: ${response.status}`);
        }
    }
    /**
     * GET /updates/evm/:chainId/:aggregatorIds
     * Fetch updates for EVM network feeds from the crossbar
     * @param param0 - The chain ID and aggregator IDs to fetch updates for
     * @returns Promise<{ results: EVMResult[]; encoded: string[] }> - The updates for the specified feeds
     */
    async fetchEVMResults({ chainId, aggregatorIds, }) {
        try {
            if (!chainId)
                throw new Error("Chain ID is required");
            if (!aggregatorIds || aggregatorIds.length === 0)
                throw new Error("At least one feed is required");
            const feedsParam = aggregatorIds.join(",");
            return await axios
                .get(`${this.crossbarUrl}/updates/evm/${chainId}/${feedsParam}`)
                .then((resp) => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar fetchEVMUpdates response: ${response.status}`);
        }
    }
    /**
     * GET /simulate/evm/:network/:aggregatorIds
     * Simulate fetching Solana feed results from the crossbar
     * @param {string} network - The Solana network to simulate
     * @param {string[]} aggregatorIds - The public keys of the feeds to simulate
     * @returns {Promise<{ feed: string; feedHash: string; results: number[] }[]>} - The simulated feed results
     */
    async simulateEVMFeeds(network, aggregatorIds) {
        try {
            if (!network)
                throw new Error("Network is required");
            if (!aggregatorIds || aggregatorIds.length === 0)
                throw new Error("At least one feed is required");
            const feedsParam = aggregatorIds.join(",");
            return await axios
                .get(`${this.crossbarUrl}/simulate/evm/${network}/${feedsParam}`)
                .then((resp) => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar simulateEVMFeeds response: ${response.status}`);
        }
    }
    /**
     * GET /randomness/evm/:chainId/:randomnessId
     * @param param0 - The chain ID and randomness ID to resolve
     */
    async resolveEVMRandomness({ chainId, randomnessId, }) {
        try {
            return await axios
                .get(`${this.crossbarUrl}/randomness/evm/${chainId}/${randomnessId}`)
                .then((resp) => resp.data);
        }
        catch (err) {
            if (!axios.isAxiosError(err))
                throw err;
            const response = err.response;
            if (!response)
                throw err;
            if (this.verbose)
                console.error(`${response.status}: ${response.data}`);
            throw new Error(`Bad Crossbar resolveEVMRandomness response: ${response.status}`);
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQ3Jvc3NiYXJDbGllbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvQ3Jvc3NiYXJDbGllbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBQ3BELE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUlqRCxPQUFPLEtBQUssTUFBTSxPQUFPLENBQUM7QUFDMUIsT0FBTyxJQUFJLE1BQU0sTUFBTSxDQUFDO0FBb0V4QixNQUFNLE9BQU8sY0FBYztJQUNoQixXQUFXLENBQVM7SUFDcEIsT0FBTyxDQUFVO0lBRTFCLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBaUI7UUFDOUIsT0FBTyxJQUFJLGNBQWMsQ0FBQyxrQ0FBa0MsRUFBRSxPQUFPLENBQUMsQ0FBQztJQUN6RSxDQUFDO0lBRUQsWUFBWSxXQUFtQixFQUFFLE9BQWlCO1FBQ2hELElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUMsTUFBTSxDQUFDO1FBQy9DLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQztJQUMzQixDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxLQUFLLENBQUMsS0FBSyxDQUFDLFFBQWdCO1FBQzFCLElBQUksQ0FBQztZQUNILE9BQU8sTUFBTSxLQUFLO2lCQUNmLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQyxXQUFXLFVBQVUsUUFBUSxFQUFFLENBQUM7aUJBQzVDLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQy9CLENBQUM7UUFBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO1lBQ2IsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsR0FBRyxDQUFDO2dCQUFFLE1BQU0sR0FBRyxDQUFDO1lBRXhDLE1BQU0sUUFBUSxHQUFHLEdBQUcsQ0FB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QUssQ0FBQyxvQkFBb0IsQ0FBQyxFQUN6QixPQUFPLEVBQ1AsWUFBWSxHQUliO1FBUUMsSUFBSSxDQUFDO1lBQ0gsT0FBTyxNQUFNLEtBQUs7aUJBQ2YsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLFdBQVcsbUJBQW1CLE9BQU8sSUFBSSxZQUFZLEVBQUUsQ0FBQztpQkFDcEUsSUFBSSxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDL0IsQ0FBQztRQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7WUFDYixJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUM7Z0JBQUUsTUFBTSxHQUFHLENBQUM7WUFFeEMsTUFBTSxRQUFRLEdBQUcsR0FBRyxDQUFDLFFBQVEsQ0FBQztZQUM5QixJQUFJLENBQUMsUUFBUTtnQkFBRSxNQUFNLEdBQUcsQ0FBQztZQUV6QixJQUFJLElBQUksQ0FBQyxPQUFPO2dCQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsR0FBRyxRQUFRLENBQUMsTUFBTSxLQUFLLFFBQVEsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDO1lBQ3hFLE1BQU0sSUFBSSxLQUFLLENBQ2IsK0NBQStDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsQ0FDakUsQ0FBQztRQUNKLENBQUM7SUFDSCxDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJeEZyb21IZXggfSBmcm9tIFwiLi91dGlscy9pbnN0cnVjdGlvbnMuanNcIjtcbmltcG9ydCB7IGRlY29kZVN0cmluZyB9IGZyb20gXCIuL3V0aWxzL3N0cmluZy5qc1wiO1xuaW1wb3J0IHR5cGUgeyBJT3JhY2xlSm9iIH0gZnJvbSBcIi4vcHJvdG9zLmpzXCI7XG5cbmltcG9ydCB0eXBlIHsgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiB9IGZyb20gXCJAc29sYW5hL3dlYjMuanNcIjtcbmltcG9ydCBheGlvcyBmcm9tIFwiYXhpb3NcIjtcbmltcG9ydCBiczU4IGZyb20gXCJiczU4XCI7XG5cbi8qKlxuICogIFRoZSByZXNwb25zZSBmcm9tIHRoZSBnYXRld2F5IGFmdGVyIGZldGNoaW5nIHNpZ25hdHVyZXMuXG4gKiAgVmFyaWFibGVzIGFyZSBzbmFrZV9jYXNlIGZvciBzZXJpYWxpemF0aW9uLlxuICovXG5leHBvcnQgdHlwZSBGZWVkRXZhbFJlc3BvbnNlID0ge1xuICAvKipcbiAgICogIEhleCBlbmNvZGVkIG9yYWNsZSBwdWJrZXlcbiAgICovXG4gIG9yYWNsZV9wdWJrZXk6IHN0cmluZztcbiAgLyoqXG4gICAqICBIZXggZW5jb2RlZCBxdWV1ZSBwdWJrZXlcbiAgICovXG4gIHF1ZXVlX3B1YmtleTogc3RyaW5nO1xuICAvKipcbiAgICogIEhleCBlbmNvZGVkIG9yYWNsZSBzaWduaW5nIHB1YmtleVxuICAgKi9cbiAgb3JhY2xlX3NpZ25pbmdfcHVia2V5OiBzdHJpbmc7XG4gIC8qKlxuICAgKiAgSGV4IGVuY29kZWQgZmVlZCBpZFxuICAgKi9cbiAgZmVlZF9oYXNoOiBzdHJpbmc7XG4gIC8qKlxuICAgKiAgSGV4IGVuY29kZWQgYmxvY2toYXNoL3Nsb3RoYXNoIHRoZSByZXNwb25zZSB3YXMgc2lnbmVkIHdpdGguXG4gICAqL1xuICByZWNlbnRfaGFzaDogc3RyaW5nO1xuICAvKipcbiAgICogIEVycm9ycyBlbmNvdW50ZXJlZCB3aGlsZSBmZXRjaGluZyBmZWVkIHZhbHVlXG4gICAqL1xuICBmYWlsdXJlX2Vycm9yOiBzdHJpbmc7XG4gIC8qKlxuICAgKiAgRmVlZCB2YWx1ZXMgZGVyaXZlZFxuICAgKi9cbiAgc3VjY2Vzc192YWx1ZTogc3RyaW5nO1xuICAvKipcbiAgICogIFNpZ25lZCBtZXNzYWdlIG9mIHRoZSByZXN1bHQgYW5kIGJsb2NraGFzaFxuICAgKi9cbiAgbXNnOiBzdHJpbmc7XG4gIC8qKlxuICAgKiAgT3JhY2xlIHNpZ25hdHVyZSBvZiB0aGUgcmVzdWx0IGFuZCBibG9ja2hhc2hcbiAgICpcbiAgICogIFNoYTI1NihzdWNjZXNzX2ZlZWRfaGFzaGVzIHx8IHJlc3VsdHMgfHwgc2xvdGhhc2gpXG4gICAqL1xuICBzaWduYXR1cmU6IHN0cmluZztcbiAgcmVjb3ZlcnlfaWQ6IG51bWJlcjtcblxuICAvKipcbiAgICogIElmIHRoZSBmZWVkIGZldGNoIGZhaWxlZCwgZ2V0IG90aGVyIHJlY2VudCBzdWNjZXNzZXNcbiAgICovXG4gIHJlY2VudF9zdWNjZXNzZXNfaWZfZmFpbGVkOiBBcnJheTxGZWVkRXZhbFJlc3BvbnNlPjtcblxuICAvKipcbiAgICogVGltZXN0YW1wIG1hcmtpbmcgd2hlbiB0aGUgcmVzdWx0IHdhcyBmZXRjaGVkXG4gICAqL1xuICB0aW1lc3RhbXA/OiBudW1iZXI7XG59O1xuXG4vKipcbiAqIFRoZSByZXNwb25zZSBmcm9tIHRoZSBnYXRld2F5IGFmdGVyIGZldGNoaW5nIHNpZ25hdHVyZXMuXG4gKi9cbmV4cG9ydCB0eXBlIEVWTVJlc3VsdCA9IEZlZWRFdmFsUmVzcG9uc2UgJiB7XG4gIC8qKlxuICAgKiAgVGhlIHJlc3VsdCBvZiB0aGUgZmVlZCBldmFsdWF0aW9uXG4gICAqL1xuICByZXN1bHQ6IG51bWJlcjtcbn07XG5cbmV4cG9ydCBjbGFzcyBDcm9zc2JhckNsaWVudCB7XG4gIHJlYWRvbmx5IGNyb3NzYmFyVXJsOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHZlcmJvc2U6IGJvb2xlYW47XG5cbiAgc3RhdGljIGRlZmF1bHQodmVyYm9zZT86IGJvb2xlYW4pIHtcbiAgICByZXR1cm4gbmV3IENyb3NzYmFyQ2xpZW50KFwiaHR0cHM6Ly9jcm9zc2Jhci5zd2l0Y2hib2FyZC54eXpcIiwgdmVyYm9zZSk7XG4gIH1cblxuICBjb25zdHJ1Y3Rvcihjcm9zc2JhclVybDogc3RyaW5nLCB2ZXJib3NlPzogYm9vbGVhbikge1xuICAgIHRoaXMuY3Jvc3NiYXJVcmwgPSBuZXcgVVJMKGNyb3NzYmFyVXJsKS5vcmlnaW47XG4gICAgdGhpcy52ZXJib3NlID0gISF2ZXJib3NlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdFVCAvZmV0Y2gvOmZlZWRIYXNoXG4gICAqIEZldGNoIGRhdGEgZnJvbSB0aGUgY3Jvc3NiYXIgdXNpbmcgdGhlIHByb3ZpZGVkIGZlZWRIYXNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmZWVkSGFzaCAtIFRoZSBoYXNoIG9mIHRoZSBmZWVkIHRvIGZldGNoIGRhdGEgZm9yXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59IC0gVGhlIGRhdGEgZmV0Y2hlZCBmcm9tIHRoZSBjcm9zc2JhclxuICAgKi9cbiAgYXN5bmMgZmV0Y2goZmVlZEhhc2g6IHN0cmluZyk6IFByb21pc2U8YW55PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBheGlvc1xuICAgICAgICAuZ2V0KGAke3RoaXMuY3Jvc3NiYXJVcmx9L2ZldGNoLyR7ZmVlZEhhc2h9YClcbiAgICAgICAgLnRoZW4oKHJlc3ApID0+IHJlc3AuZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIWF4aW9zLmlzQXhpb3NFcnJvcihlcnIpKSB0aHJvdyBlcnI7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gZXJyLnJlc3BvbnNlO1xuICAgICAgaWYgKCFyZXNwb25zZSkgdGhyb3cgZXJyO1xuXG4gICAgICAvLyBJZiByZXNwb25zZSBpcyBvdXRzaWRlIG9mIHRoZSAyMDAgcmFuZ2UsIGxvZyB0aGUgc3RhdHVzIGFuZCB0aHJvdyBhbiBlcnJvci5cbiAgICAgIGlmICh0aGlzLnZlcmJvc2UpIGNvbnNvbGUuZXJyb3IoYCR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5kYXRhfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCYWQgQ3Jvc3NiYXIgZmV0Y2ggc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUE9TVCAvc3RvcmVcbiAgICogU3RvcmUgb3JhY2xlIGpvYnMgb24gdGhlIGNyb3NzYmFyLCBhc3NvY2lhdGVkIHdpdGggYSBxdWV1ZSBhZGRyZXNzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBxdWV1ZUFkZHJlc3MgLSBUaGUgYWRkcmVzcyBvZiB0aGUgcXVldWVcbiAgICogQHBhcmFtIHtJT3JhY2xlSm9iW119IGpvYnMgLSBUaGUgb3JhY2xlIGpvYnMgdG8gc3RvcmVcbiAgICogQHJldHVybnMge1Byb21pc2U8eyBjaWQ6IHN0cmluZzsgZmVlZEhhc2g6IHN0cmluZzsgcXVldWVIZXg6IHN0cmluZyB9Pn0gLSBUaGUgc3RvcmVkIGRhdGEgaW5mb3JtYXRpb25cbiAgICovXG4gIGFzeW5jIHN0b3JlKFxuICAgIHF1ZXVlQWRkcmVzczogc3RyaW5nLFxuICAgIGpvYnM6IElPcmFjbGVKb2JbXVxuICApOiBQcm9taXNlPHsgY2lkOiBzdHJpbmc7IGZlZWRIYXNoOiBzdHJpbmc7IHF1ZXVlSGV4OiBzdHJpbmcgfT4ge1xuICAgIHRyeSB7XG4gICAgICAvLyBUcnkgdG8gZGVjb2RlIHRoZSBxdWV1ZUFkZHJlc3MgdG8gYSBCdWZmZXIgc28gdGhhdCB3ZSBjYW4gc2VuZCBpdCBpbiB0aGUgZXhwZWN0ZWQgZm9ybWF0LFxuICAgICAgLy8gYmFzZTU4LCB0byB0aGUgQ3Jvc3NiYXIgbm9kZS5cbiAgICAgIGNvbnN0IHF1ZXVlID0gZGVjb2RlU3RyaW5nKHF1ZXVlQWRkcmVzcyk7XG4gICAgICBpZiAoIXF1ZXVlKSB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBwYXJzZSBxdWV1ZTogJHtxdWV1ZUFkZHJlc3N9YCk7XG5cbiAgICAgIHJldHVybiBhd2FpdCBheGlvc1xuICAgICAgICAucG9zdChcbiAgICAgICAgICBgJHt0aGlzLmNyb3NzYmFyVXJsfS9zdG9yZWAsXG4gICAgICAgICAgeyBxdWV1ZTogYnM1OC5lbmNvZGUocXVldWUpLCBqb2JzIH0sXG4gICAgICAgICAgeyBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0gfVxuICAgICAgICApXG4gICAgICAgIC50aGVuKChyZXNwKSA9PiByZXNwLmRhdGEpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCFheGlvcy5pc0F4aW9zRXJyb3IoZXJyKSkgdGhyb3cgZXJyO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGVyci5yZXNwb25zZTtcbiAgICAgIGlmICghcmVzcG9uc2UpIHRocm93IGVycjtcblxuICAgICAgaWYgKHRoaXMudmVyYm9zZSkgY29uc29sZS5lcnJvcihgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLmRhdGF9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEJhZCBDcm9zc2JhciBzdG9yZSByZXNwb25zZTogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdFVCAvc2ltdWxhdGUvOmZlZWRIYXNoZXNcbiAgICogU2ltdWxhdGUgZmV0Y2hpbmcgZmVlZCByZXN1bHRzIGZyb20gdGhlIGNyb3NzYmFyIHVzaW5nIGZlZWQgaGFzaGVzXG4gICAqIEBwYXJhbSB7c3RyaW5nW119IGZlZWRIYXNoZXMgLSBUaGUgaGFzaGVzIG9mIHRoZSBmZWVkcyB0byBzaW11bGF0ZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7IGZlZWRIYXNoOiBzdHJpbmc7IHJlc3VsdHM6IG51bWJlcltdIH1bXT59IC0gVGhlIHNpbXVsYXRlZCBmZWVkIHJlc3VsdHNcbiAgICovXG4gIGFzeW5jIHNpbXVsYXRlRmVlZHMoXG4gICAgZmVlZEhhc2hlczogc3RyaW5nW11cbiAgKTogUHJvbWlzZTx7IGZlZWRIYXNoOiBzdHJpbmc7IHJlc3VsdHM6IG51bWJlcltdIH1bXT4ge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIWZlZWRIYXNoZXMgfHwgZmVlZEhhc2hlcy5sZW5ndGggPT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSBmZWVkIGlzIHJlcXVpcmVkXCIpO1xuXG4gICAgICBjb25zdCBmZWVkc1BhcmFtID0gZmVlZEhhc2hlcy5qb2luKFwiLFwiKTtcbiAgICAgIHJldHVybiBhd2FpdCBheGlvc1xuICAgICAgICAuZ2V0KGAke3RoaXMuY3Jvc3NiYXJVcmx9L3NpbXVsYXRlLyR7ZmVlZHNQYXJhbX1gKVxuICAgICAgICAudGhlbigocmVzcCkgPT4gcmVzcC5kYXRhKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICghYXhpb3MuaXNBeGlvc0Vycm9yKGVycikpIHRocm93IGVycjtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBlcnIucmVzcG9uc2U7XG4gICAgICBpZiAoIXJlc3BvbnNlKSB0aHJvdyBlcnI7XG5cbiAgICAgIGlmICh0aGlzLnZlcmJvc2UpIGNvbnNvbGUuZXJyb3IoYCR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5kYXRhfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCYWQgQ3Jvc3NiYXIgc2ltdWxhdGVGZWVkIHJlc3BvbnNlOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR0VUIC91cGRhdGVzL3NvbGFuYS86bmV0d29yay86ZmVlZHB1YmtleXNcbiAgICogRmV0Y2ggdXBkYXRlcyBmb3IgU29sYW5hIG5ldHdvcmsgZmVlZHMgZnJvbSB0aGUgY3Jvc3NiYXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmsgLSBUaGUgU29sYW5hIG5ldHdvcmsgdG8gZmV0Y2ggdXBkYXRlcyBmb3JcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gZmVlZHB1YmtleXMgLSBUaGUgcHVibGljIGtleXMgb2YgdGhlIGZlZWRzIHRvIGZldGNoIHVwZGF0ZXMgZm9yXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbnVtU2lnbmF0dXJlc10gLSBUaGUgbnVtYmVyIG9mIHNpZ25hdHVyZXMgdG8gZmV0Y2ggKG9wdGlvbmFsKVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7IHN1Y2Nlc3M6IGJvb2xlYW47IHB1bGxJeDogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbjsgcmVzcG9uc2VzOiB7IG9yYWNsZTogc3RyaW5nOyByZXN1bHQ6IG51bWJlciB8IG51bGw7IGVycm9yczogc3RyaW5nIH1bXTsgbG9va3VwVGFibGVzOiBzdHJpbmdbXSB9W10+fSAtIFRoZSB1cGRhdGVzIGZvciB0aGUgc3BlY2lmaWVkIGZlZWRzXG4gICAqL1xuICBhc3luYyBmZXRjaFNvbGFuYVVwZGF0ZXMoXG4gICAgbmV0d29yazogc3RyaW5nLFxuICAgIGZlZWRwdWJrZXlzOiBzdHJpbmdbXSxcbiAgICBudW1TaWduYXR1cmVzPzogbnVtYmVyXG4gICk6IFByb21pc2U8XG4gICAge1xuICAgICAgc3VjY2VzczogYm9vbGVhbjtcbiAgICAgIHB1bGxJeDogVHJhbnNhY3Rpb25JbnN0cnVjdGlvbjtcbiAgICAgIHJlc3BvbnNlczogeyBvcmFjbGU6IHN0cmluZzsgcmVzdWx0OiBudW1iZXIgfCBudWxsOyBlcnJvcnM6IHN0cmluZyB9W107XG4gICAgICBsb29rdXBUYWJsZXM6IHN0cmluZ1tdO1xuICAgIH1bXVxuICA+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFuZXR3b3JrKSB0aHJvdyBuZXcgRXJyb3IoXCJOZXR3b3JrIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgaWYgKCFmZWVkcHVia2V5cyB8fCBmZWVkcHVia2V5cy5sZW5ndGggPT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSBmZWVkIGlzIHJlcXVpcmVkXCIpO1xuXG4gICAgICBjb25zdCBmZWVkc1BhcmFtID0gZmVlZHB1YmtleXMuam9pbihcIixcIik7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zXG4gICAgICAgIC5nZXQoYCR7dGhpcy5jcm9zc2JhclVybH0vdXBkYXRlcy9zb2xhbmEvJHtuZXR3b3JrfS8ke2ZlZWRzUGFyYW19YCwge1xuICAgICAgICAgIHBhcmFtczogeyBudW1TaWduYXR1cmVzIH0sXG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKChyZXNwKSA9PiByZXNwLmRhdGEpO1xuXG4gICAgICAvLyBDb252ZXJ0IHB1bGxJeCBmcm9tIGhleCB0byBUcmFuc2FjdGlvbkluc3RydWN0aW9uIHVzaW5nIEl4RnJvbUhleFxuICAgICAgY29uc3QgdXBkYXRlcyA9IHJlc3BvbnNlLm1hcCgodXBkYXRlOiBhbnkpID0+ICh7XG4gICAgICAgIC4uLnVwZGF0ZSxcbiAgICAgICAgcHVsbEl4OiBJeEZyb21IZXgodXBkYXRlLnB1bGxJeCksXG4gICAgICB9KSk7XG5cbiAgICAgIHJldHVybiB1cGRhdGVzO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCFheGlvcy5pc0F4aW9zRXJyb3IoZXJyKSkgdGhyb3cgZXJyO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGVyci5yZXNwb25zZTtcbiAgICAgIGlmICghcmVzcG9uc2UpIHRocm93IGVycjtcblxuICAgICAgaWYgKHRoaXMudmVyYm9zZSkgY29uc29sZS5lcnJvcihgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLmRhdGF9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBCYWQgQ3Jvc3NiYXIgZmV0Y2hTb2xhbmFVcGRhdGVzIHJlc3BvbnNlOiAke3Jlc3BvbnNlLnN0YXR1c31gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHRVQgL3NpbXVsYXRlL3NvbGFuYS86bmV0d29yay86ZmVlZHB1YmtleXNcbiAgICogU2ltdWxhdGUgZmV0Y2hpbmcgU29sYW5hIGZlZWQgcmVzdWx0cyBmcm9tIHRoZSBjcm9zc2JhclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV0d29yayAtIFRoZSBTb2xhbmEgbmV0d29yayB0byBzaW11bGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBmZWVkcHVia2V5cyAtIFRoZSBwdWJsaWMga2V5cyBvZiB0aGUgZmVlZHMgdG8gc2ltdWxhdGVcbiAgICogQHJldHVybnMge1Byb21pc2U8eyBmZWVkOiBzdHJpbmc7IGZlZWRIYXNoOiBzdHJpbmc7IHJlc3VsdHM6IG51bWJlcltdIH1bXT59IC0gVGhlIHNpbXVsYXRlZCBmZWVkIHJlc3VsdHNcbiAgICovXG4gIGFzeW5jIHNpbXVsYXRlU29sYW5hRmVlZHMoXG4gICAgbmV0d29yazogc3RyaW5nLFxuICAgIGZlZWRwdWJrZXlzOiBzdHJpbmdbXVxuICApOiBQcm9taXNlPHsgZmVlZDogc3RyaW5nOyBmZWVkSGFzaDogc3RyaW5nOyByZXN1bHRzOiBudW1iZXJbXSB9W10+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFuZXR3b3JrKSB0aHJvdyBuZXcgRXJyb3IoXCJOZXR3b3JrIGlzIHJlcXVpcmVkXCIpO1xuICAgICAgaWYgKCFmZWVkcHVia2V5cyB8fCBmZWVkcHVia2V5cy5sZW5ndGggPT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSBmZWVkIGlzIHJlcXVpcmVkXCIpO1xuXG4gICAgICBjb25zdCBmZWVkc1BhcmFtID0gZmVlZHB1YmtleXMuam9pbihcIixcIik7XG4gICAgICByZXR1cm4gYXdhaXQgYXhpb3NcbiAgICAgICAgLmdldChgJHt0aGlzLmNyb3NzYmFyVXJsfS9zaW11bGF0ZS9zb2xhbmEvJHtuZXR3b3JrfS8ke2ZlZWRzUGFyYW19YClcbiAgICAgICAgLnRoZW4oKHJlc3ApID0+IHJlc3AuZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIWF4aW9zLmlzQXhpb3NFcnJvcihlcnIpKSB0aHJvdyBlcnI7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gZXJyLnJlc3BvbnNlO1xuICAgICAgaWYgKCFyZXNwb25zZSkgdGhyb3cgZXJyO1xuXG4gICAgICBpZiAodGhpcy52ZXJib3NlKSBjb25zb2xlLmVycm9yKGAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2UuZGF0YX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEJhZCBDcm9zc2JhciBzaW11bGF0ZVNvbGFuYUZlZWRzIHJlc3BvbnNlOiAke3Jlc3BvbnNlLnN0YXR1c31gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHRVQgL3VwZGF0ZXMvZXZtLzpjaGFpbklkLzphZ2dyZWdhdG9ySWRzXG4gICAqIEZldGNoIHVwZGF0ZXMgZm9yIEVWTSBuZXR3b3JrIGZlZWRzIGZyb20gdGhlIGNyb3NzYmFyXG4gICAqIEBwYXJhbSBwYXJhbTAgLSBUaGUgY2hhaW4gSUQgYW5kIGFnZ3JlZ2F0b3IgSURzIHRvIGZldGNoIHVwZGF0ZXMgZm9yXG4gICAqIEByZXR1cm5zIFByb21pc2U8eyByZXN1bHRzOiBFVk1SZXN1bHRbXTsgZW5jb2RlZDogc3RyaW5nW10gfT4gLSBUaGUgdXBkYXRlcyBmb3IgdGhlIHNwZWNpZmllZCBmZWVkc1xuICAgKi9cbiAgYXN5bmMgZmV0Y2hFVk1SZXN1bHRzKHtcbiAgICBjaGFpbklkLFxuICAgIGFnZ3JlZ2F0b3JJZHMsXG4gIH06IHtcbiAgICBjaGFpbklkOiBudW1iZXI7XG4gICAgYWdncmVnYXRvcklkczogc3RyaW5nW107XG4gIH0pOiBQcm9taXNlPHsgcmVzdWx0czogRVZNUmVzdWx0W107IGVuY29kZWQ6IHN0cmluZ1tdIH0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFjaGFpbklkKSB0aHJvdyBuZXcgRXJyb3IoXCJDaGFpbiBJRCBpcyByZXF1aXJlZFwiKTtcbiAgICAgIGlmICghYWdncmVnYXRvcklkcyB8fCBhZ2dyZWdhdG9ySWRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXQgbGVhc3Qgb25lIGZlZWQgaXMgcmVxdWlyZWRcIik7XG5cbiAgICAgIGNvbnN0IGZlZWRzUGFyYW0gPSBhZ2dyZWdhdG9ySWRzLmpvaW4oXCIsXCIpO1xuICAgICAgcmV0dXJuIGF3YWl0IGF4aW9zXG4gICAgICAgIC5nZXQoYCR7dGhpcy5jcm9zc2JhclVybH0vdXBkYXRlcy9ldm0vJHtjaGFpbklkfS8ke2ZlZWRzUGFyYW19YClcbiAgICAgICAgLnRoZW4oKHJlc3ApID0+IHJlc3AuZGF0YSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoIWF4aW9zLmlzQXhpb3NFcnJvcihlcnIpKSB0aHJvdyBlcnI7XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gZXJyLnJlc3BvbnNlO1xuICAgICAgaWYgKCFyZXNwb25zZSkgdGhyb3cgZXJyO1xuXG4gICAgICBpZiAodGhpcy52ZXJib3NlKSBjb25zb2xlLmVycm9yKGAke3Jlc3BvbnNlLnN0YXR1c306ICR7cmVzcG9uc2UuZGF0YX1gKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYEJhZCBDcm9zc2JhciBmZXRjaEVWTVVwZGF0ZXMgcmVzcG9uc2U6ICR7cmVzcG9uc2Uuc3RhdHVzfWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdFVCAvc2ltdWxhdGUvZXZtLzpuZXR3b3JrLzphZ2dyZWdhdG9ySWRzXG4gICAqIFNpbXVsYXRlIGZldGNoaW5nIFNvbGFuYSBmZWVkIHJlc3VsdHMgZnJvbSB0aGUgY3Jvc3NiYXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ldHdvcmsgLSBUaGUgU29sYW5hIG5ldHdvcmsgdG8gc2ltdWxhdGVcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gYWdncmVnYXRvcklkcyAtIFRoZSBwdWJsaWMga2V5cyBvZiB0aGUgZmVlZHMgdG8gc2ltdWxhdGVcbiAgICogQHJldHVybnMge1Byb21pc2U8eyBmZWVkOiBzdHJpbmc7IGZlZWRIYXNoOiBzdHJpbmc7IHJlc3VsdHM6IG51bWJlcltdIH1bXT59IC0gVGhlIHNpbXVsYXRlZCBmZWVkIHJlc3VsdHNcbiAgICovXG4gIGFzeW5jIHNpbXVsYXRlRVZNRmVlZHMoXG4gICAgbmV0d29yazogbnVtYmVyLFxuICAgIGFnZ3JlZ2F0b3JJZHM6IHN0cmluZ1tdXG4gICk6IFByb21pc2U8eyBhZ2dyZWdhdG9ySWQ6IHN0cmluZzsgZmVlZEhhc2g6IHN0cmluZzsgcmVzdWx0czogbnVtYmVyW10gfVtdPiB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghbmV0d29yaykgdGhyb3cgbmV3IEVycm9yKFwiTmV0d29yayBpcyByZXF1aXJlZFwiKTtcbiAgICAgIGlmICghYWdncmVnYXRvcklkcyB8fCBhZ2dyZWdhdG9ySWRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXQgbGVhc3Qgb25lIGZlZWQgaXMgcmVxdWlyZWRcIik7XG5cbiAgICAgIGNvbnN0IGZlZWRzUGFyYW0gPSBhZ2dyZWdhdG9ySWRzLmpvaW4oXCIsXCIpO1xuICAgICAgcmV0dXJuIGF3YWl0IGF4aW9zXG4gICAgICAgIC5nZXQoYCR7dGhpcy5jcm9zc2JhclVybH0vc2ltdWxhdGUvZXZtLyR7bmV0d29ya30vJHtmZWVkc1BhcmFtfWApXG4gICAgICAgIC50aGVuKChyZXNwKSA9PiByZXNwLmRhdGEpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKCFheGlvcy5pc0F4aW9zRXJyb3IoZXJyKSkgdGhyb3cgZXJyO1xuXG4gICAgICBjb25zdCByZXNwb25zZSA9IGVyci5yZXNwb25zZTtcbiAgICAgIGlmICghcmVzcG9uc2UpIHRocm93IGVycjtcblxuICAgICAgaWYgKHRoaXMudmVyYm9zZSkgY29uc29sZS5lcnJvcihgJHtyZXNwb25zZS5zdGF0dXN9OiAke3Jlc3BvbnNlLmRhdGF9YCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBCYWQgQ3Jvc3NiYXIgc2ltdWxhdGVFVk1GZWVkcyByZXNwb25zZTogJHtyZXNwb25zZS5zdGF0dXN9YFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR0VUIC9yYW5kb21uZXNzL2V2bS86Y2hhaW5JZC86cmFuZG9tbmVzc0lkXG4gICAqIEBwYXJhbSBwYXJhbTAgLSBUaGUgY2hhaW4gSUQgYW5kIHJhbmRvbW5lc3MgSUQgdG8gcmVzb2x2ZVxuICAgKi9cbiAgYXN5bmMgcmVzb2x2ZUVWTVJhbmRvbW5lc3Moe1xuICAgIGNoYWluSWQsXG4gICAgcmFuZG9tbmVzc0lkLFxuICB9OiB7XG4gICAgY2hhaW5JZDogbnVtYmVyO1xuICAgIHJhbmRvbW5lc3NJZDogc3RyaW5nO1xuICB9KTogUHJvbWlzZTx7XG4gICAgZW5jb2RlZDogc3RyaW5nO1xuICAgIHJlc3BvbnNlOiB7XG4gICAgICBzaWduYXR1cmU6IHN0cmluZztcbiAgICAgIHJlY292ZXJ5X2lkOiBudW1iZXI7XG4gICAgICB2YWx1ZTogc3RyaW5nO1xuICAgIH07XG4gIH0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGF4aW9zXG4gICAgICAgIC5nZXQoYCR7dGhpcy5jcm9zc2JhclVybH0vcmFuZG9tbmVzcy9ldm0vJHtjaGFpbklkfS8ke3JhbmRvbW5lc3NJZH1gKVxuICAgICAgICAudGhlbigocmVzcCkgPT4gcmVzcC5kYXRhKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICghYXhpb3MuaXNBeGlvc0Vycm9yKGVycikpIHRocm93IGVycjtcblxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBlcnIucmVzcG9uc2U7XG4gICAgICBpZiAoIXJlc3BvbnNlKSB0aHJvdyBlcnI7XG5cbiAgICAgIGlmICh0aGlzLnZlcmJvc2UpIGNvbnNvbGUuZXJyb3IoYCR7cmVzcG9uc2Uuc3RhdHVzfTogJHtyZXNwb25zZS5kYXRhfWApO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQmFkIENyb3NzYmFyIHJlc29sdmVFVk1SYW5kb21uZXNzIHJlc3BvbnNlOiAke3Jlc3BvbnNlLnN0YXR1c31gXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuIl19