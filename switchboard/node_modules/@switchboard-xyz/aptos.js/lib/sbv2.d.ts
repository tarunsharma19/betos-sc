/// <reference types="node" resolution-mode="require"/>
import * as types from "./generated/types/index.js";
import type { AccountAddressInput, Aptos, SimpleTransaction } from "@aptos-labs/ts-sdk";
import { Account } from "@aptos-labs/ts-sdk";
import { Big, OracleJob } from "@switchboard-xyz/common";
export { IOracleJob, OracleJob } from "@switchboard-xyz/common";
export declare const SWITCHBOARD_DEVNET_ADDRESS = "0xb91d3fef0eeb4e685dc85e739c7d3e2968784945be4424e92e2f86e2418bf271";
export declare const SWITCHBOARD_TESTNET_ADDRESS = "0xb91d3fef0eeb4e685dc85e739c7d3e2968784945be4424e92e2f86e2418bf271";
export declare const SWITCHBOARD_MAINNET_ADDRESS = "0x7d7e436f0b2aafde60774efb26ccc432cf881b677aca7faaf2a01879bd19fb8";
export declare class AptosDecimal {
    readonly mantissa: string;
    readonly scale: number;
    readonly neg: boolean;
    constructor(mantissa: string, scale: number, neg: boolean);
    toBig(): Big;
    static fromBig(val: Big): AptosDecimal;
    static fromObj(obj: Object): AptosDecimal;
}
export declare enum SwitchboardPermission {
    PERMIT_ORACLE_HEARTBEAT = 0,
    PERMIT_ORACLE_QUEUE_USAGE = 1,
    PERMIT_VRF_REQUESTS = 2
}
export interface AggregatorAddJobParams {
    job: AccountAddressInput;
    weight?: number;
}
export interface AggregatorInitParams {
    authority: AccountAddressInput;
    name?: string;
    metadata?: string;
    queueAddress: AccountAddressInput;
    crankAddress: AccountAddressInput;
    batchSize: number;
    minOracleResults: number;
    minJobResults: number;
    minUpdateDelaySeconds: number;
    startAfter?: number;
    varianceThreshold?: Big;
    forceReportPeriod?: number;
    expiration?: number;
    disableCrank?: boolean;
    historySize?: number;
    readCharge?: number;
    rewardEscrow?: string;
    readWhitelist?: AccountAddressInput[];
    limitReadsToWhitelist?: boolean;
    seed?: AccountAddressInput;
    coinType?: string;
}
export interface AggregatorSaveResultParams {
    oracleAddress: AccountAddressInput;
    oracleIdx: number;
    error: boolean;
    value: Big;
    jobsChecksum: string;
    minResponse: Big;
    maxResponse: Big;
}
export interface OracleSaveResultParams extends AggregatorSaveResultParams {
    aggregatorAddress: AccountAddressInput;
}
export interface JobInitParams {
    name: string;
    metadata: string;
    authority: AccountAddressInput;
    data: string;
    weight?: number;
}
export interface AggregatorRemoveJobParams {
    aggregatorAddress: string;
    job: string;
}
export interface AggregatorSetConfigParams {
    authority?: string;
    name?: string;
    metadata?: string;
    queueAddress?: AccountAddressInput;
    crankAddress?: AccountAddressInput;
    batchSize?: number;
    minOracleResults?: number;
    minJobResults?: number;
    minUpdateDelaySeconds?: number;
    startAfter?: number;
    varianceThreshold?: Big;
    forceReportPeriod?: number;
    expiration?: number;
    disableCrank?: boolean;
    historySize?: number;
    readCharge?: number;
    rewardEscrow?: AccountAddressInput;
    readWhitelist?: AccountAddressInput[];
    limitReadsToWhitelist?: boolean;
}
export interface AggregatorSetFeedRelayParams {
    aggregator_addr: AccountAddressInput;
    relay_authority: AccountAddressInput;
    oracle_keys: string[];
}
export interface AggregatorSetFeedRelayOracleKeys {
    aggregator_addr: AccountAddressInput;
    oracle_keys: string[];
}
export interface CrankInitParams {
    queueAddress: AccountAddressInput;
    coinType?: string;
}
export interface CrankPopParams {
    crankAddress: string;
}
export interface CrankPushParams {
    aggregatorAddress: string;
}
export interface OracleInitParams {
    name: string;
    metadata: string;
    authority: AccountAddressInput;
    queue: AccountAddressInput;
    coinType?: string;
    seed?: AccountAddressInput;
}
export interface OracleQueueInitParams {
    authority: AccountAddressInput;
    name: string;
    metadata: string;
    oracleTimeout: number;
    reward: number;
    minStake: number;
    slashingEnabled: boolean;
    varianceToleranceMultiplierValue: number;
    varianceToleranceMultiplierScale: number;
    feedProbationPeriod: number;
    consecutiveFeedFailureLimit: number;
    consecutiveOracleFailureLimit: number;
    unpermissionedFeedsEnabled: boolean;
    unpermissionedVrfEnabled: boolean;
    lockLeaseFunding: boolean;
    enableBufferRelayers: boolean;
    maxSize: number;
    save_confirmation_reward?: number;
    save_reward?: number;
    open_round_reward?: number;
    slashing_penalty?: number;
    coinType?: string;
}
export interface OracleQueueSetConfigsParams {
    name: string;
    metadata: string;
    authority: AccountAddressInput;
    oracleTimeout: number;
    reward: number;
    minStake: number;
    slashingEnabled: boolean;
    varianceToleranceMultiplierValue: number;
    varianceToleranceMultiplierScale: number;
    feedProbationPeriod: number;
    consecutiveFeedFailureLimit: number;
    consecutiveOracleFailureLimit: number;
    unpermissionedFeedsEnabled: boolean;
    unpermissionedVrfEnabled?: boolean;
    lockLeaseFunding: boolean;
    enableBufferRelayers: boolean;
    maxSize: number;
    save_confirmation_reward?: number;
    save_reward?: number;
    open_round_reward?: number;
    slashing_penalty?: number;
}
export interface LeaseInitParams {
    aggregatorAddress: AccountAddressInput;
    queueAddress: AccountAddressInput;
    withdrawAuthority: AccountAddressInput;
    initialAmount: number;
    coinType?: string;
}
export interface LeaseExtendParams {
    queueAddress: AccountAddressInput;
    loadAmount: number;
}
export interface LeaseWithdrawParams {
    queueAddress: AccountAddressInput;
    amount: number;
}
export interface LeaseSetAuthorityParams {
    queueAddress: AccountAddressInput;
    authority: AccountAddressInput;
}
export interface OracleWalletInitParams {
    oracleAddress: AccountAddressInput;
    queueAddress: AccountAddressInput;
    coinType?: string;
}
export interface OracleWalletContributeParams {
    oracleAddress: AccountAddressInput;
    queueAddress: AccountAddressInput;
    loadAmount: number;
}
export interface OracleWalletWithdrawParams {
    oracleAddress: AccountAddressInput;
    queueAddress: AccountAddressInput;
    amount: number;
}
export interface PermissionInitParams {
    authority: AccountAddressInput;
    granter: AccountAddressInput;
    grantee: AccountAddressInput;
}
export interface PermissionSetParams {
    authority: AccountAddressInput;
    granter: AccountAddressInput;
    grantee: AccountAddressInput;
    permission: SwitchboardPermission;
    enable: boolean;
}
export type EventCallback = (e: any) => Promise<void> /** | (() => Promise<void>) */;
/**
 * Sends and waits for an aptos tx to be confirmed
 * @param client
 * @param signer
 * @param method Aptos module method (ex: 0xSwitchboard::aggregator_add_job_action)
 * @param args Arguments for method (converts numbers to strings)
 * @returns
 */
export declare function sendAptosTx(client: Aptos, signer: Account, method: `${string}::${string}::${string}`, args: Array<any>, type_args?: Array<string>, maxGasPrice?: number): Promise<string>;
/**
 * Send a built simple transaction
 * @param client
 * @param signer
 * @param simple_tx
 * @param maxGasPrice
 * @returns
 */
export declare function sendSimpleAptosTx(client: Aptos, signer: Account, simple_tx: SimpleTransaction, maxGasPrice?: number): Promise<string>;
/**
 * Generates an aptos tx for client
 * @param method Aptos module method (ex: 0xSwitchboard::aggregator_add_job_action)
 * @param args Arguments for method (converts numbers to strings)
 * @param type_args Arguments for type_args
 * @returns
 */
export declare function getAptosTx(aptosClient: Aptos, sender: string, method: `${string}::${string}::${string}`, args: Array<any>, type_args?: Array<string>): Promise<SimpleTransaction>;
export declare const sendRawAptosTx: typeof sendAptosTx;
/**
 * Poll Events on Aptos
 * @Note uncleared setTimeout calls will keep processes from ending organically (SIGTERM is needed)
 */
export declare class AptosEvent {
    readonly client: Aptos;
    readonly eventHandlerOwner: AccountAddressInput;
    readonly eventOwnerStruct: `${string}::${string}::${string}`;
    readonly eventHandlerName: string;
    readonly pollIntervalMs: number;
    intervalId?: ReturnType<typeof setInterval>;
    constructor(client: Aptos, eventHandlerOwner: AccountAddressInput, eventOwnerStruct: `${string}::${string}::${string}`, eventHandlerName: string, pollIntervalMs?: number);
    onTrigger(callback: EventCallback, errorHandler?: (error: unknown) => void): Promise<NodeJS.Timer>;
    stop(): void;
}
export declare class StateAccount {
    readonly client: Aptos;
    readonly address: AccountAddressInput;
    readonly payer: Account;
    readonly switchboardAddress: AccountAddressInput;
    constructor(client: Aptos, address: AccountAddressInput, payer: Account, switchboardAddress: AccountAddressInput);
    static init(client: Aptos, account: Account, switchboardAddress: AccountAddressInput): Promise<[StateAccount, string]>;
    loadData(): Promise<any>;
}
export declare class AggregatorAccount {
    readonly client: Aptos;
    readonly address: AccountAddressInput;
    readonly switchboardAddress: AccountAddressInput;
    readonly coinType: string;
    constructor(client: Aptos, address: AccountAddressInput, switchboardAddress: AccountAddressInput, coinType?: string);
    loadData(): Promise<types.Aggregator>;
    loadJobs(): Promise<Array<OracleJob>>;
    static loadMultiple(client: Aptos, aggregators: AccountAddressInput[], switchboardAddress: AccountAddressInput): Promise<any>;
    /**
     * Initialize an Aggregator
     * @param client
     * @param account
     * @param params AggregatorInitParams initialization params
     */
    static init(client: Aptos, account: Account, params: AggregatorInitParams, switchboardAddress: AccountAddressInput): Promise<[AggregatorAccount, string]>;
    latestValue(): Promise<number>;
    addJob(account: Account, params: AggregatorAddJobParams): Promise<string>;
    addJobTx(sender: Account, params: AggregatorAddJobParams): Promise<SimpleTransaction>;
    removeJobTx(sender: Account, params: AggregatorAddJobParams): Promise<SimpleTransaction>;
    saveResult(account: Account, params: AggregatorSaveResultParams, maxGasPrice?: number): Promise<string>;
    openRound(account: Account, jitter?: number, maxGasPrice?: number): Promise<string>;
    static openRoundN(client: Aptos, account: Account, aggregatorAddresses: AccountAddressInput[], switchboardAddress: AccountAddressInput, jitter?: number, coinType?: string, maxGasPrice?: number): Promise<string>;
    openRoundTx(sender: Account): Promise<SimpleTransaction>;
    setConfigTx(sender: Account, params: AggregatorSetConfigParams): Promise<SimpleTransaction>;
    setConfig(account: Account, params: AggregatorSetConfigParams): Promise<string>;
    static watch(client: Aptos, switchboardAddress: AccountAddressInput, callback: EventCallback, pollingIntervalMs?: number): AptosEvent;
    static shouldReportValue(value: Big, aggregator: types.Aggregator): Promise<boolean>;
}
export declare class JobAccount {
    readonly client: Aptos;
    readonly address: AccountAddressInput;
    readonly switchboardAddress: AccountAddressInput;
    constructor(client: Aptos, address: AccountAddressInput, switchboardAddress: AccountAddressInput);
    loadData(): Promise<types.Job>;
    loadJob(): Promise<OracleJob>;
    /**
     * Initialize a JobAccount
     * @param client
     * @param account
     * @param params JobInitParams initialization params
     */
    static init(client: Aptos, account: Account, params: JobInitParams, switchboardAddress: AccountAddressInput): Promise<[JobAccount, string]>;
    /**
     * Initialize a JobAccount
     * @param client
     * @param account
     * @param params JobInitParams initialization params
     */
    static initTx(client: Aptos, sender: Account, account: AccountAddressInput, params: JobInitParams, switchboardAddress: AccountAddressInput): Promise<[JobAccount, SimpleTransaction]>;
}
export declare class CrankAccount {
    readonly client: Aptos;
    readonly address: AccountAddressInput;
    readonly switchboardAddress: AccountAddressInput;
    readonly coinType: string;
    constructor(client: Aptos, address: AccountAddressInput, switchboardAddress: AccountAddressInput, coinType?: string);
    /**
     * Initialize a Crank
     * @param client
     * @param account account that will be the authority of the Crank
     * @param params CrankInitParams initialization params
     */
    static init(client: Aptos, account: Account, params: CrankInitParams, switchboardAddress: AccountAddressInput): Promise<[CrankAccount, string]>;
    /**
     * Push an aggregator to a Crank
     * @param params CrankPushParams
     */
    push(account: Account, params: CrankPushParams): Promise<string>;
    pushTx(sender: Account, params: CrankPushParams): Promise<SimpleTransaction>;
    /**
     * Pop an aggregator off the Crank
     */
    pop(account: Account, pop_idx?: number): Promise<string>;
    /**
     * Pop many aggregators off the Crank
     */
    pop_n(account: Account, pop_list: number[]): Promise<string>;
    loadData(): Promise<types.Crank>;
}
export declare class OracleAccount {
    readonly client: Aptos;
    readonly address: AccountAddressInput;
    readonly switchboardAddress: AccountAddressInput;
    readonly coinType: string;
    constructor(client: Aptos, address: AccountAddressInput, switchboardAddress: AccountAddressInput, coinType?: string);
    /**
     * Initialize a Oracle
     * @param client
     * @param account
     * @param params Oracle initialization params
     */
    static init(client: Aptos, account: Account, params: OracleInitParams, switchboardAddress: AccountAddressInput): Promise<[OracleAccount, string]>;
    loadData(): Promise<types.Oracle>;
    /**
     * Oracle Heartbeat Action
     */
    heartbeat(account: Account): Promise<string>;
    /**
     * Oracle Bulk Save Results Action
     */
    saveManyResult(account: Account, params: OracleSaveResultParams[], maxGasPrice?: number): Promise<string>;
}
export declare class OracleQueueAccount {
    readonly client: Aptos;
    readonly address: AccountAddressInput;
    readonly switchboardAddress: AccountAddressInput;
    readonly coinType: string;
    constructor(client: Aptos, address: AccountAddressInput, switchboardAddress: AccountAddressInput, coinType?: string);
    /**
     * Initialize an OracleQueueAccount
     * @param client
     * @param account
     * @param params OracleQueueAccount initialization params
     */
    static init(client: Aptos, account: Account, params: OracleQueueInitParams, switchboardAddress: AccountAddressInput): Promise<[OracleQueueAccount, string]>;
    setConfigs(account: Account, params: OracleQueueSetConfigsParams): Promise<string>;
    loadData(): Promise<types.OracleQueue>;
}
/**
 * Leases are kept in a LeaseManager resource on the same account that an Aggregator
 * exists on.
 */
export declare class LeaseAccount {
    readonly client: Aptos;
    readonly address: AccountAddressInput;
    readonly switchboardAddress: AccountAddressInput;
    readonly coinType: string;
    constructor(client: Aptos, address: AccountAddressInput, switchboardAddress: AccountAddressInput, coinType?: string);
    /**
     * Initialize a LeaseAccount
     * @param client
     * @param account account that will be the authority of the LeaseAccount
     * @param params LeaseInitParams initialization params
     */
    static init(client: Aptos, account: Account, params: LeaseInitParams, switchboardAddress: AccountAddressInput): Promise<[LeaseAccount, string]>;
    /**
     * Extend a lease
     * @param params CrankPushParams
     */
    extend(account: Account, params: LeaseExtendParams): Promise<string>;
    /**
     * Extend a lease tx
     * @param params CrankPushParams
     */
    extendTx(sender: Account, params: LeaseExtendParams): Promise<SimpleTransaction>;
    /**
     * Pop an aggregator off the Crank
     */
    withdraw(account: Account, params: LeaseWithdrawParams): Promise<string>;
    /**
     * Pop an aggregator off the Crank
     */
    withdrawTx(sender: Account, params: LeaseWithdrawParams): Promise<SimpleTransaction>;
    /**
     * Set a lease authority
     * @param params CrankPushParams
     */
    setAuthority(account: Account, params: LeaseSetAuthorityParams): Promise<string>;
    loadData(queueAddress: AccountAddressInput): Promise<types.Escrow>;
}
export declare class EscrowManager {
    readonly client: Aptos;
    readonly address: AccountAddressInput;
    readonly switchboardAddress: AccountAddressInput;
    readonly coinType: string;
    constructor(client: Aptos, address: AccountAddressInput, switchboardAddress: AccountAddressInput, coinType?: string);
    loadData(): Promise<types.EscrowManager>;
    fetchItem(queueAddress: AccountAddressInput): Promise<types.Escrow>;
    static fetchItem<T extends {
        client: Aptos;
        address: AccountAddressInput;
        switchboardAddress: AccountAddressInput;
        coinType?: string;
    }>(account: T, queueAddress: AccountAddressInput): Promise<types.Escrow>;
}
export declare class OracleWallet {
    readonly client: Aptos;
    readonly address: AccountAddressInput;
    readonly switchboardAddress: AccountAddressInput;
    readonly coinType: string;
    constructor(client: Aptos, address: AccountAddressInput, switchboardAddress: AccountAddressInput, coinType?: string);
    /**
     * Initialize an OracleWallet
     * @param client
     * @param account account that will be the authority of the OracleWallet
     * @param params OracleWalletInitParams initialization params
     */
    static init(client: Aptos, account: Account, params: OracleWalletInitParams, switchboardAddress: AccountAddressInput): Promise<[OracleWallet, string]>;
    /**
     * Contributes to an oracle wallet
     * @param params OracleWalletContributeParams
     */
    contribute(account: Account, params: OracleWalletContributeParams): Promise<string>;
    /**
     * Withdraw from an OracleWallet
     */
    withdraw(account: Account, params: OracleWalletWithdrawParams): Promise<string>;
    loadData(queueAddress: AccountAddressInput): Promise<any>;
}
export declare class Permission {
    readonly client: Aptos;
    readonly switchboardAddress: AccountAddressInput;
    constructor(client: Aptos, switchboardAddress: AccountAddressInput);
    /**
     * Initialize a Permission
     * @param client
     * @param account
     * @param params PermissionInitParams initialization params
     */
    static init(client: Aptos, account: Account, params: PermissionInitParams, switchboardAddress: AccountAddressInput): Promise<[Permission, string]>;
    /**
     * Set a Permission
     */
    set(account: Account, params: PermissionSetParams): Promise<string>;
}
interface CreateFeedParams extends AggregatorInitParams {
    jobs: JobInitParams[];
    initialLoadAmount: number;
}
type CreateOracleParams = OracleInitParams;
export declare function createFeedTx(client: Aptos, sender: Account, params: CreateFeedParams, switchboardAddress: AccountAddressInput): Promise<[AggregatorAccount, SimpleTransaction]>;
export declare function createFeed(client: Aptos, account: Account, params: CreateFeedParams, switchboardAddress: AccountAddressInput): Promise<[AggregatorAccount, string]>;
export declare function createOracle(client: Aptos, account: Account, params: CreateOracleParams, switchboardAddress: AccountAddressInput): Promise<[OracleAccount, string]>;
export declare function bcsAddressToBytes(hexStr: AccountAddressInput): Uint8Array;
export declare function generateResourceAccountAddress(origin: AccountAddressInput, seed: Uint8Array): AccountAddressInput;
export declare function fetchAggregators(client: Aptos, authority: AccountAddressInput, switchboardAddress: AccountAddressInput): Promise<any[]>;
//# sourceMappingURL=sbv2.d.ts.map