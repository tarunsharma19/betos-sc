"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.fetchAggregators = exports.generateResourceAccountAddress = exports.bcsAddressToBytes = exports.createOracle = exports.createFeed = exports.createFeedTx = exports.Permission = exports.OracleWallet = exports.EscrowManager = exports.LeaseAccount = exports.OracleQueueAccount = exports.OracleAccount = exports.CrankAccount = exports.JobAccount = exports.AggregatorAccount = exports.StateAccount = exports.AptosEvent = exports.sendRawAptosTx = exports.getAptosTx = exports.sendSimpleAptosTx = exports.sendAptosTx = exports.SwitchboardPermission = exports.AptosDecimal = exports.SWITCHBOARD_MAINNET_ADDRESS = exports.SWITCHBOARD_TESTNET_ADDRESS = exports.SWITCHBOARD_DEVNET_ADDRESS = exports.OracleJob = void 0;
const types = __importStar(require("./generated/types/index.cjs"));
const SwitchboardError_js_1 = require("./SwitchboardError.cjs");
const SwitchboardProgram_js_1 = require("./SwitchboardProgram.cjs");
const ts_sdk_1 = require("@aptos-labs/ts-sdk");
const common_1 = require("@switchboard-xyz/common");
const aptos_1 = require("aptos");
const SHA3 = __importStar(require("js-sha3"));
const lodash_1 = __importDefault(require("lodash"));
const DEFAULT_COINTYPE = "0x1::aptos_coin::AptosCoin";
var common_2 = require("@switchboard-xyz/common");
Object.defineProperty(exports, "OracleJob", { enumerable: true, get: function () { return common_2.OracleJob; } });
exports.SWITCHBOARD_DEVNET_ADDRESS = `0xb91d3fef0eeb4e685dc85e739c7d3e2968784945be4424e92e2f86e2418bf271`;
exports.SWITCHBOARD_TESTNET_ADDRESS = `0xb91d3fef0eeb4e685dc85e739c7d3e2968784945be4424e92e2f86e2418bf271`;
exports.SWITCHBOARD_MAINNET_ADDRESS = `0x7d7e436f0b2aafde60774efb26ccc432cf881b677aca7faaf2a01879bd19fb8`;
class AptosDecimal {
    mantissa;
    scale;
    neg;
    constructor(mantissa, scale, neg) {
        this.mantissa = mantissa;
        this.scale = scale;
        this.neg = neg;
    }
    toBig() {
        const oldDp = common_1.Big.DP;
        common_1.Big.DP = 18;
        let result = new common_1.Big(this.mantissa);
        if (this.neg === true) {
            result = result.mul(-1);
        }
        const TEN = new common_1.Big(10);
        result = safeDiv(result, TEN.pow(this.scale));
        common_1.Big.DP = oldDp;
        return result;
    }
    static fromBig(val) {
        const value = val.c.slice();
        const e = val.e + 1;
        while (value.length - e > 9) {
            value.pop();
        }
        // Aptos decimals cannot have a negative scale
        while (value.length - e < 0) {
            value.push(0);
        }
        return new AptosDecimal(value.join(""), value.length - e, val.s === -1);
    }
    static fromObj(obj) {
        const properties = ["mantissa", "scale", "neg"];
        properties.forEach((p) => {
            if (!(p in obj)) {
                throw new Error(`Object is missing property ${p}`);
            }
        });
        return new AptosDecimal(obj["mantissa"], obj["scale"], obj["neg"]);
    }
}
exports.AptosDecimal = AptosDecimal;
var SwitchboardPermission;
(function (SwitchboardPermission) {
    SwitchboardPermission[SwitchboardPermission["PERMIT_ORACLE_HEARTBEAT"] = 0] = "PERMIT_ORACLE_HEARTBEAT";
    SwitchboardPermission[SwitchboardPermission["PERMIT_ORACLE_QUEUE_USAGE"] = 1] = "PERMIT_ORACLE_QUEUE_USAGE";
    SwitchboardPermission[SwitchboardPermission["PERMIT_VRF_REQUESTS"] = 2] = "PERMIT_VRF_REQUESTS";
})(SwitchboardPermission || (exports.SwitchboardPermission = SwitchboardPermission = {}));
/**
 * Sends and waits for an aptos tx to be confirmed
 * @param client
 * @param signer
 * @param method Aptos module method (ex: 0xSwitchboard::aggregator_add_job_action)
 * @param args Arguments for method (converts numbers to strings)
 * @returns
 */
async function sendAptosTx(client, signer, method, args, type_args = [], maxGasPrice = 2000) {
    const simple_tx = await client.transaction.build.simple({
        sender: signer.accountAddress,
        data: {
            typeArguments: type_args,
            functionArguments: args,
            function: method,
        },
    });
    try {
        const simulation = (await client.transaction.simulate.simple({
            signerPublicKey: signer.publicKey,
            transaction: simple_tx,
            options: {
                estimateGasUnitPrice: true,
                estimateMaxGasAmount: true,
                estimatePrioritizedGasUnitPrice: true,
            },
        }))[0];
        if (Number(simulation.gas_unit_price) > maxGasPrice) {
            throw Error(`Estimated gas price from simulation ${simulation.gas_unit_price} above maximum (${maxGasPrice}).`);
        }
        if (simulation.success === false) {
            throw new SwitchboardProgram_js_1.AptosSimulationError(simulation.vm_status);
        }
        const transactionRes = await client.signAndSubmitTransaction({
            signer,
            transaction: simple_tx,
        });
        // wait for tx to land
        await client.waitForTransaction({
            transactionHash: transactionRes.hash,
        });
        return transactionRes.hash;
    }
    catch (error) {
        const switchboardError = (0, SwitchboardError_js_1.handleError)(error);
        if (switchboardError) {
            throw switchboardError;
        }
        throw error;
    }
}
exports.sendAptosTx = sendAptosTx;
/**
 * Send a built simple transaction
 * @param client
 * @param signer
 * @param simple_tx
 * @param maxGasPrice
 * @returns
 */
async function sendSimpleAptosTx(client, signer, simple_tx, maxGasPrice = 2000) {
    try {
        const simulation = (await client.transaction.simulate.simple({
            signerPublicKey: signer.publicKey,
            transaction: simple_tx,
            options: {
                estimateGasUnitPrice: true,
                estimateMaxGasAmount: true,
                estimatePrioritizedGasUnitPrice: true,
            },
        }))[0];
        if (Number(simulation.gas_unit_price) > maxGasPrice) {
            throw Error(`Estimated gas price from simulation ${simulation.gas_unit_price} above maximum (${maxGasPrice}).`);
        }
        if (simulation.success === false) {
            throw new SwitchboardProgram_js_1.AptosSimulationError(simulation.vm_status);
        }
        const transactionRes = await client.signAndSubmitTransaction({
            signer,
            transaction: simple_tx,
        });
        // wait for tx to land
        await client.waitForTransaction({
            transactionHash: transactionRes.hash,
        });
        return transactionRes.hash;
    }
    catch (error) {
        const switchboardError = (0, SwitchboardError_js_1.handleError)(error);
        if (switchboardError) {
            throw switchboardError;
        }
        throw error;
    }
}
exports.sendSimpleAptosTx = sendSimpleAptosTx;
/**
 * Generates an aptos tx for client
 * @param method Aptos module method (ex: 0xSwitchboard::aggregator_add_job_action)
 * @param args Arguments for method (converts numbers to strings)
 * @param type_args Arguments for type_args
 * @returns
 */
function getAptosTx(aptosClient, sender, method, args, type_args = []) {
    return aptosClient.transaction.build.simple({
        sender: sender,
        data: {
            typeArguments: type_args,
            functionArguments: args,
            function: method,
        },
    });
}
exports.getAptosTx = getAptosTx;
// Alias for sendAptosTx - since sendAptosTx now handles bcs for you
exports.sendRawAptosTx = sendAptosTx;
/**
 * Poll Events on Aptos
 * @Note uncleared setTimeout calls will keep processes from ending organically (SIGTERM is needed)
 */
class AptosEvent {
    client;
    eventHandlerOwner;
    eventOwnerStruct;
    eventHandlerName;
    pollIntervalMs;
    intervalId;
    constructor(client, eventHandlerOwner, eventOwnerStruct, eventHandlerName, pollIntervalMs = 1000) {
        this.client = client;
        this.eventHandlerOwner = eventHandlerOwner;
        this.eventOwnerStruct = eventOwnerStruct;
        this.eventHandlerName = eventHandlerName;
        this.pollIntervalMs = pollIntervalMs;
    }
    async onTrigger(callback, errorHandler) {
        let lastSequenceNumber = "0";
        const ownerData = await this.client.getAccountResource({
            accountAddress: this.eventHandlerOwner,
            resourceType: this.eventOwnerStruct,
        });
        try {
            lastSequenceNumber = (Number(ownerData[this.eventHandlerName].counter) - 1).toString();
        }
        catch (error) {
            console.error(JSON.stringify(ownerData, undefined, 2), error);
        }
        if (Number(ownerData[this.eventHandlerName].counter) === -1) {
            lastSequenceNumber = "0";
        }
        const deprecatedClient = new aptos_1.AptosClient(this.client.config.network);
        this.intervalId = setInterval(async () => {
            try {
                const events = await deprecatedClient.getEventsByEventHandle(this.eventHandlerOwner.toString(), this.eventOwnerStruct, this.eventHandlerName, {
                    start: BigInt(Number(lastSequenceNumber) + 1),
                    limit: 500,
                });
                if (events && events.length !== 0) {
                    // increment sequence number
                    const last = lodash_1.default.last(events);
                    if (last) {
                        lastSequenceNumber = last.sequence_number;
                    }
                }
                for (const event of events) {
                    callback(event).catch((error) => {
                        if (errorHandler) {
                            errorHandler(error);
                        }
                        else {
                            throw error;
                        }
                    });
                }
            }
            catch (error) {
                if (errorHandler) {
                    errorHandler(error);
                }
            }
        }, this.pollIntervalMs);
        return this.intervalId;
    }
    stop() {
        clearInterval(this.intervalId);
    }
}
exports.AptosEvent = AptosEvent;
class StateAccount {
    client;
    address;
    payer;
    switchboardAddress;
    constructor(client, address, payer, switchboardAddress) {
        this.client = client;
        this.address = address;
        this.payer = payer;
        this.switchboardAddress = switchboardAddress;
    }
    static async init(client, account, switchboardAddress) {
        const tx = await sendAptosTx(client, account, `${switchboardAddress}::switchboard_init_action::run`, []);
        return [
            new StateAccount(client, account.accountAddress, account, switchboardAddress),
            tx,
        ];
    }
    async loadData() {
        return await this.client.getAccountResource({
            accountAddress: this.address,
            resourceType: `${this.switchboardAddress}::switchboard::State`,
        });
    }
}
exports.StateAccount = StateAccount;
class AggregatorAccount {
    client;
    address;
    switchboardAddress;
    coinType;
    constructor(client, address, switchboardAddress, coinType = DEFAULT_COINTYPE) {
        this.client = client;
        this.address = address;
        this.switchboardAddress = switchboardAddress;
        this.coinType = coinType;
    }
    async loadData() {
        const results = await this.client.getAccountResources({
            accountAddress: this.address,
        });
        const agg = results.reduce((prev, current) => {
            return {
                ...prev,
                ...current.data,
            };
        }, {});
        const latestConfirmedRound = results
            .filter((res) => res.type ===
            `${this.switchboardAddress}::aggregator::AggregatorRound<${this.switchboardAddress}::aggregator::LatestConfirmedRound>`)
            .pop().data;
        const currentRound = results
            .filter((res) => res.type ===
            `${this.switchboardAddress}::aggregator::AggregatorRound<${this.switchboardAddress}::aggregator::CurrentRound>`)
            .pop().data;
        // removed field current_payout
        // @ts-ignore
        currentRound.current_payout = [];
        // @ts-ignore
        latestConfirmedRound.current_payout = [];
        // @ts-ignore
        agg.current_round = currentRound;
        // @ts-ignore
        agg.latest_confirmed_round = latestConfirmedRound;
        return types.Aggregator.fromMoveStruct(agg);
    }
    async loadJobs() {
        const data = await this.loadData();
        const jobs = data.jobKeys.map((key) => new JobAccount(this.client, key, this.switchboardAddress));
        const promises = [];
        for (const job of jobs) {
            promises.push(job.loadJob());
        }
        return await Promise.all(promises);
    }
    static async loadMultiple(client, aggregators, switchboardAddress) {
        // TODO: Fix this type
        return await client.view({
            payload: {
                function: `${switchboardAddress}::aggregator_fetch_multiple::run`,
                functionArguments: [aggregators],
                typeArguments: [],
            },
        });
    }
    /**
     * Initialize an Aggregator
     * @param client
     * @param account
     * @param params AggregatorInitParams initialization params
     */
    static async init(client, account, params, switchboardAddress) {
        const { mantissa: vtMantissa, scale: vtScale } = AptosDecimal.fromBig(params.varianceThreshold ?? new common_1.Big(0));
        const seed = params.seed ? params.seed : ts_sdk_1.Account.generate().accountAddress;
        const resource_address = generateResourceAccountAddress(account.accountAddress, bcsAddressToBytes(seed));
        const aggregatorAccount = new AggregatorAccount(client, resource_address, switchboardAddress, params.coinType);
        const tx = await sendAptosTx(client, account, `${switchboardAddress}::aggregator_init_action::run`, [
            params.name ?? "",
            params.metadata ?? "",
            params.queueAddress,
            params.crankAddress,
            params.batchSize,
            params.minOracleResults,
            params.minJobResults,
            params.minUpdateDelaySeconds,
            params.startAfter ?? 0,
            Number(vtMantissa),
            Number(vtScale),
            params.forceReportPeriod ?? 0,
            params.expiration ?? 0,
            params.disableCrank ?? false,
            params.historySize ?? 0,
            params.readCharge ?? 0,
            params.rewardEscrow ? params.rewardEscrow : account.accountAddress,
            params.readWhitelist ?? [],
            params.limitReadsToWhitelist ?? false,
            params.authority,
            seed,
        ], [aggregatorAccount.coinType]);
        return [aggregatorAccount, tx];
    }
    async latestValue() {
        const data = await this.loadData();
        return new AptosDecimal(data.latestConfirmedRound.result.value.toString(), data.latestConfirmedRound.result.dec, Boolean(data.latestConfirmedRound.result.neg))
            .toBig()
            .toNumber();
    }
    async addJob(account, params) {
        return await sendAptosTx(this.client, account, `${this.switchboardAddress}::aggregator_add_job_action::run`, [this.address, params.job, params.weight || 1]);
    }
    addJobTx(sender, params) {
        return getAptosTx(this.client, sender.accountAddress.toString(), `${this.switchboardAddress}::aggregator_add_job_action::run`, [this.address, params.job, params.weight || 1]);
    }
    removeJobTx(sender, params) {
        return getAptosTx(this.client, sender.accountAddress.toString(), `${this.switchboardAddress}::aggregator_remove_job_action::run`, [this.address, params.job]);
    }
    async saveResult(account, params, maxGasPrice = 400) {
        const { mantissa: valueMantissa, scale: valueScale, neg: valueNeg, } = AptosDecimal.fromBig(params.value);
        const { mantissa: minResponseMantissa, scale: minResponseScale, neg: minResponseNeg, } = AptosDecimal.fromBig(params.minResponse);
        const { mantissa: maxResponseMantissa, scale: maxResponseScale, neg: maxResponseNeg, } = AptosDecimal.fromBig(params.maxResponse);
        return (0, exports.sendRawAptosTx)(this.client, account, `${this.switchboardAddress}::aggregator_save_result_action::run`, [
            aptos_1.BCS.bcsToBytes(aptos_1.TxnBuilderTypes.AccountAddress.fromHex(params.oracleAddress.toString())),
            aptos_1.BCS.bcsToBytes(aptos_1.TxnBuilderTypes.AccountAddress.fromHex(this.address.toString())),
            aptos_1.BCS.bcsSerializeUint64(params.oracleIdx),
            aptos_1.BCS.bcsSerializeBool(params.error),
            aptos_1.BCS.bcsSerializeU128(Number(valueMantissa)),
            aptos_1.BCS.bcsSerializeU8(valueScale),
            aptos_1.BCS.bcsSerializeBool(valueNeg),
            aptos_1.BCS.bcsSerializeBytes(ts_sdk_1.Hex.fromHexString(params.jobsChecksum).toUint8Array()),
            aptos_1.BCS.bcsSerializeU128(Number(minResponseMantissa)),
            aptos_1.BCS.bcsSerializeU8(minResponseScale),
            aptos_1.BCS.bcsSerializeBool(minResponseNeg),
            aptos_1.BCS.bcsSerializeU128(Number(maxResponseMantissa)),
            aptos_1.BCS.bcsSerializeU8(maxResponseScale),
            aptos_1.BCS.bcsSerializeBool(maxResponseNeg),
        ], [this.coinType], maxGasPrice);
    }
    async openRound(account, jitter = 1, maxGasPrice = 400) {
        return await sendAptosTx(this.client, account, `${this.switchboardAddress}::aggregator_open_round_action::run`, [this.address, jitter], [this.coinType], maxGasPrice);
    }
    static async openRoundN(client, account, aggregatorAddresses, switchboardAddress, jitter = 1, coinType = DEFAULT_COINTYPE, maxGasPrice = 400) {
        return await sendAptosTx(client, account, `${switchboardAddress}::aggregator_open_round_action::run_many`, [aggregatorAddresses.map((addr) => addr), jitter], [coinType], maxGasPrice);
    }
    openRoundTx(sender) {
        return getAptosTx(this.client, sender.accountAddress.toString(), `${this.switchboardAddress}::aggregator_open_round_action::run`, [this.address, 1], [this.coinType]);
    }
    async setConfigTx(sender, params) {
        const aggregator = await this.loadData();
        // TODO
        const { mantissa: vtMantissa, scale: vtScale } = AptosDecimal.fromBig(params.varianceThreshold ?? new common_1.Big(0));
        const tx = getAptosTx(this.client, sender.accountAddress.toString(), `${this.switchboardAddress}::aggregator_set_configs_action::run`, [
            this.address,
            params.name ?? aggregator.name,
            params.metadata ?? aggregator.metadata,
            params.queueAddress ?? aggregator.queueAddr,
            params.crankAddress ?? aggregator.crankAddr,
            params.batchSize ?? aggregator.batchSize.toNumber(),
            params.minOracleResults ?? aggregator.minOracleResults.toNumber(),
            params.minJobResults ?? aggregator.minJobResults.toNumber(),
            params.minUpdateDelaySeconds ??
                aggregator.minUpdateDelaySeconds.toNumber(),
            params.startAfter ?? aggregator.startAfter.toNumber(),
            params.varianceThreshold
                ? Number(vtMantissa)
                : aggregator.varianceThreshold.value.toNumber(),
            params.varianceThreshold ? vtScale : aggregator.varianceThreshold.dec,
            params.forceReportPeriod ?? aggregator.forceReportPeriod.toNumber(),
            params.expiration ?? aggregator.expiration.toNumber(), // @ts-ignore
            params.disableCrank ?? false, // @ts-ignore
            params.historySize ?? 0, // @ts-ignore
            params.readCharge ?? aggregator.readCharge.toNumber(),
            params.rewardEscrow ? params.rewardEscrow : aggregator.rewardEscrow,
            params.readWhitelist ?? aggregator.readWhitelist,
            params.limitReadsToWhitelist ?? aggregator.limitReadsToWhitelist,
            params.authority ?? aggregator.authority,
        ], [this.coinType]);
        return tx;
    }
    async setConfig(account, params) {
        const aggregator = await this.loadData();
        // TODO: this looks wrong
        const { mantissa: vtMantissa, scale: vtScale } = AptosDecimal.fromBig(params.varianceThreshold ?? new common_1.Big(0));
        const paramsRaw = [
            this.address,
            params.name ?? aggregator.name,
            params.metadata ?? aggregator.metadata,
            params.queueAddress ?? aggregator.queueAddr,
            params.crankAddress ?? aggregator.crankAddr,
            params.batchSize ?? aggregator.batchSize.toNumber(),
            params.minOracleResults ?? aggregator.minOracleResults.toNumber(),
            params.minJobResults ?? aggregator.minJobResults.toNumber(),
            params.minUpdateDelaySeconds ??
                aggregator.minUpdateDelaySeconds.toNumber(),
            params.startAfter ?? aggregator.startAfter.toNumber(),
            params.varianceThreshold
                ? Number(vtMantissa)
                : aggregator.varianceThreshold.value.toNumber(),
            params.varianceThreshold ? vtScale : aggregator.varianceThreshold.dec,
            params.forceReportPeriod ?? aggregator.forceReportPeriod.toNumber(),
            params.expiration ?? aggregator.expiration.toNumber(), // @ts-ignore
            params.disableCrank ?? false, // @ts-ignore
            params.historySize ?? 0, // @ts-ignore
            params.readCharge ?? aggregator.readCharge.toNumber(),
            params.rewardEscrow ? params.rewardEscrow : aggregator.rewardEscrow,
            params.readWhitelist ?? aggregator.readWhitelist,
            params.limitReadsToWhitelist ?? aggregator.limitReadsToWhitelist,
            params.authority ?? aggregator.authority,
        ];
        return await sendAptosTx(this.client, account, `${this.switchboardAddress}::aggregator_set_configs_action::run`, paramsRaw, [this.coinType]);
    }
    static watch(client, switchboardAddress, callback, pollingIntervalMs = 1000) {
        const switchboardAccountAddressInput = switchboardAddress;
        const event = new AptosEvent(client, switchboardAccountAddressInput, `${switchboardAccountAddressInput}::switchboard::State`, "aggregator_update_events", pollingIntervalMs);
        event.onTrigger(callback);
        return event;
    }
    static async shouldReportValue(value, aggregator) {
        if ((aggregator.latestConfirmedRound?.numSuccess.toNumber() ?? 0) === 0) {
            return true;
        }
        const timestamp = new common_1.BN(Math.round(Date.now() / 1000), 10);
        const startAfter = new common_1.BN(aggregator.startAfter, 10);
        if (startAfter.gt(timestamp)) {
            return false;
        }
        const varianceThreshold = new AptosDecimal(aggregator.varianceThreshold.value.toString(10), aggregator.varianceThreshold.dec, Boolean(aggregator.varianceThreshold.neg)).toBig();
        const latestResult = new AptosDecimal(aggregator.latestConfirmedRound.result.value.toString(), aggregator.latestConfirmedRound.result.dec, Boolean(aggregator.latestConfirmedRound.result.neg)).toBig();
        const forceReportPeriod = new common_1.BN(aggregator.forceReportPeriod, 10);
        const lastTimestamp = new common_1.BN(aggregator.latestConfirmedRound.roundOpenTimestamp, 10);
        if (lastTimestamp.add(forceReportPeriod).lt(timestamp)) {
            return true;
        }
        let diff = safeDiv(latestResult, value);
        if (diff.abs().gt(1)) {
            diff = safeDiv(value, latestResult);
        }
        // I dont want to think about variance percentage when values cross 0.
        // Changes the scale of what we consider a "percentage".
        if (diff.lt(0)) {
            return true;
        }
        const change = new common_1.Big(1).minus(diff);
        return change.gt(varianceThreshold);
    }
}
exports.AggregatorAccount = AggregatorAccount;
class JobAccount {
    client;
    address;
    switchboardAddress;
    constructor(client, address, switchboardAddress) {
        this.client = client;
        this.address = address;
        this.switchboardAddress = switchboardAddress;
    }
    async loadData() {
        const data = await this.client.getAccountResource({
            accountAddress: this.address,
            resourceType: `${this.switchboardAddress}::job::Job`,
        });
        return types.Job.fromMoveStruct(data);
    }
    async loadJob() {
        const data = await this.loadData();
        // on-chain hex encoded base64 -> base64 -> Uint8Array -> OracleJob
        const job = common_1.OracleJob.decodeDelimited(Buffer.from(Buffer.from(data.data).toString(), "base64"));
        return job;
    }
    /**
     * Initialize a JobAccount
     * @param client
     * @param account
     * @param params JobInitParams initialization params
     */
    static async init(client, account, params, switchboardAddress) {
        const tx = await sendAptosTx(client, account, `${switchboardAddress}::job_init_action::run`, [params.name, params.metadata, params.authority, params.data]);
        return [
            new JobAccount(client, account.accountAddress, switchboardAddress),
            tx,
        ];
    }
    /**
     * Initialize a JobAccount
     * @param client
     * @param account
     * @param params JobInitParams initialization params
     */
    static async initTx(client, sender, account, params, switchboardAddress) {
        const tx = await getAptosTx(client, sender.accountAddress.toString(), `${switchboardAddress}::job_init_action::run`, [params.name, params.metadata, params.authority, params.data]);
        return [new JobAccount(client, account, switchboardAddress), tx];
    }
}
exports.JobAccount = JobAccount;
class CrankAccount {
    client;
    address;
    switchboardAddress;
    coinType;
    constructor(client, address, switchboardAddress, coinType = DEFAULT_COINTYPE) {
        this.client = client;
        this.address = address;
        this.switchboardAddress = switchboardAddress;
        this.coinType = coinType;
    }
    /**
     * Initialize a Crank
     * @param client
     * @param account account that will be the authority of the Crank
     * @param params CrankInitParams initialization params
     */
    static async init(client, account, params, switchboardAddress) {
        const crankAccount = new CrankAccount(client, account.accountAddress, switchboardAddress, params.coinType);
        const tx = await sendAptosTx(client, account, `${switchboardAddress}::crank_init_action::run`, [params.queueAddress], [crankAccount.coinType]);
        return [crankAccount, tx];
    }
    /**
     * Push an aggregator to a Crank
     * @param params CrankPushParams
     */
    async push(account, params) {
        return await sendAptosTx(this.client, account, `${this.switchboardAddress}::crank_push_action::run`, [this.address, params.aggregatorAddress], [this.coinType]);
    }
    pushTx(sender, params) {
        return getAptosTx(this.client, sender.accountAddress.toString(), `${this.switchboardAddress}::crank_push_action::run`, [this.address, params.aggregatorAddress], [this.coinType]);
    }
    /**
     * Pop an aggregator off the Crank
     */
    async pop(account, pop_idx) {
        return await sendAptosTx(this.client, account, `${this.switchboardAddress}::crank_pop_action::run`, [this.address, pop_idx ?? 0], [this.coinType]);
    }
    /**
     * Pop many aggregators off the Crank
     */
    async pop_n(account, pop_list) {
        return await sendAptosTx(this.client, account, `${this.switchboardAddress}::crank_pop_n_action::run`, [this.address, pop_list], [this.coinType]);
    }
    async loadData() {
        const data = await this.client.getAccountResource({
            accountAddress: this.address,
            resourceType: `${this.switchboardAddress}::crank::Crank`,
        });
        return types.Crank.fromMoveStruct(data);
    }
}
exports.CrankAccount = CrankAccount;
class OracleAccount {
    client;
    address;
    switchboardAddress;
    coinType;
    constructor(client, address, switchboardAddress, coinType = DEFAULT_COINTYPE) {
        this.client = client;
        this.address = address;
        this.switchboardAddress = switchboardAddress;
        this.coinType = coinType;
    }
    /**
     * Initialize a Oracle
     * @param client
     * @param account
     * @param params Oracle initialization params
     */
    static async init(client, account, params, switchboardAddress) {
        const seed = params.seed ? params.seed : ts_sdk_1.Account.generate().accountAddress;
        const resource_address = generateResourceAccountAddress(account.accountAddress, bcsAddressToBytes(seed));
        const oracleAccount = new OracleAccount(client, resource_address, switchboardAddress, params.coinType);
        const tx = await sendAptosTx(client, account, `${switchboardAddress}::oracle_init_action::run`, [params.name, params.metadata, params.authority, params.queue, seed], [oracleAccount.coinType]);
        return [oracleAccount, tx];
    }
    async loadData() {
        const oracleTypes = new Set([
            `${this.switchboardAddress}::oracle::Oracle`,
            `${this.switchboardAddress}::oracle::OracleData`,
            `${this.switchboardAddress}::oracle::OracleConfig`,
        ]);
        const datas = await this.client.getAccountResources({
            accountAddress: this.address,
        });
        const metrics = datas.find((data) => data.type === `${this.switchboardAddress}::oracle::OracleMetrics`);
        const oracleData = datas.filter((resource) => oracleTypes.has(resource.type));
        oracleData.push({
            type: "::::",
            data: {
                // @ts-ignore
                metrics: metrics.data,
            },
        });
        // merge queue data
        const data = oracleData.reduce((prev, curr) => ({ ...prev, ...curr.data }), {});
        return types.Oracle.fromMoveStruct(data);
    }
    /**
     * Oracle Heartbeat Action
     */
    async heartbeat(account) {
        return await sendAptosTx(this.client, account, `${this.switchboardAddress}::oracle_heartbeat_action::run`, [this.address], [this.coinType]);
    }
    /**
     * Oracle Bulk Save Results Action
     */
    async saveManyResult(account, params, maxGasPrice = 400) {
        const aggregator_addrs = [];
        const oracle_addrs = [];
        const oracle_idxs = [];
        const errors = [];
        const value_nums = [];
        const value_scale_factors = [];
        const value_negs = [];
        const jobs_checksums = [];
        const min_response_nums = [];
        const min_response_scale_factors = [];
        const min_response_negs = [];
        const max_response_nums = [];
        const max_response_scale_factors = [];
        const max_response_negs = [];
        for (const param of params) {
            const { mantissa: valueMantissa, scale: valueScale, neg: valueNeg, } = AptosDecimal.fromBig(param.value);
            const { mantissa: minResponseMantissa, scale: minResponseScale, neg: minResponseNeg, } = AptosDecimal.fromBig(param.minResponse);
            const { mantissa: maxResponseMantissa, scale: maxResponseScale, neg: maxResponseNeg, } = AptosDecimal.fromBig(param.maxResponse);
            aggregator_addrs.push(param.aggregatorAddress);
            oracle_addrs.push(param.oracleAddress);
            oracle_idxs.push(param.oracleIdx);
            errors.push(param.error);
            value_nums.push(valueMantissa);
            value_scale_factors.push(valueScale);
            value_negs.push(valueNeg);
            jobs_checksums.push(param.jobsChecksum);
            min_response_nums.push(minResponseMantissa);
            min_response_scale_factors.push(minResponseScale);
            min_response_negs.push(minResponseNeg);
            max_response_nums.push(maxResponseMantissa);
            max_response_scale_factors.push(maxResponseScale);
            max_response_negs.push(maxResponseNeg);
        }
        return sendAptosTx(this.client, account, `${this.switchboardAddress}::oracle_save_result_action::run`, [
            this.address,
            aggregator_addrs.map((addr) => addr),
            oracle_idxs.map((idx) => idx),
            errors.map((err) => err),
            value_nums.map((val) => Number(val)),
            value_scale_factors.map((scale) => scale),
            value_negs.map((neg) => neg),
            jobs_checksums.map((checksum) => ts_sdk_1.Hex.fromHexString(checksum).toUint8Array()),
            min_response_nums.map((val) => Number(val)),
            min_response_scale_factors.map((scale) => scale),
            min_response_negs.map((neg) => neg),
            max_response_nums.map((val) => Number(val)),
            max_response_scale_factors.map((scale) => scale),
            max_response_negs.map((neg) => neg),
        ], [this.coinType], maxGasPrice);
    }
}
exports.OracleAccount = OracleAccount;
class OracleQueueAccount {
    client;
    address;
    switchboardAddress;
    coinType;
    constructor(client, address, switchboardAddress, coinType = DEFAULT_COINTYPE) {
        this.client = client;
        this.address = address;
        this.switchboardAddress = switchboardAddress;
        this.coinType = coinType;
    }
    /**
     * Initialize an OracleQueueAccount
     * @param client
     * @param account
     * @param params OracleQueueAccount initialization params
     */
    static async init(client, account, params, switchboardAddress) {
        const oracleQueueAccount = new OracleQueueAccount(client, account.accountAddress, switchboardAddress, params.coinType);
        const tx = await sendAptosTx(client, account, `${switchboardAddress}::oracle_queue_init_action::run`, [
            params.authority,
            params.name,
            params.metadata,
            params.oracleTimeout,
            params.reward,
            params.minStake,
            params.slashingEnabled,
            params.varianceToleranceMultiplierValue,
            params.varianceToleranceMultiplierScale,
            params.feedProbationPeriod,
            params.consecutiveFeedFailureLimit,
            params.consecutiveOracleFailureLimit,
            params.unpermissionedFeedsEnabled,
            params.unpermissionedVrfEnabled,
            params.lockLeaseFunding,
            params.enableBufferRelayers,
            params.maxSize,
            params.save_confirmation_reward ?? 0,
            params.save_reward ?? 0,
            params.open_round_reward ?? 0,
            params.slashing_penalty ?? 0,
        ], [oracleQueueAccount.coinType]);
        return [oracleQueueAccount, tx];
    }
    async setConfigs(account, params) {
        return await sendAptosTx(this.client, account, `${this.switchboardAddress}::oracle_queue_set_configs_action::run`, [
            this.address,
            params.name,
            params.metadata,
            params.authority,
            params.oracleTimeout,
            params.reward,
            params.minStake,
            params.slashingEnabled,
            params.varianceToleranceMultiplierValue,
            params.varianceToleranceMultiplierScale,
            params.feedProbationPeriod,
            params.consecutiveFeedFailureLimit,
            params.consecutiveOracleFailureLimit,
            params.unpermissionedFeedsEnabled,
            params.lockLeaseFunding,
            params.maxSize,
            params.save_confirmation_reward ?? 0,
            params.save_reward ?? 0,
            params.open_round_reward ?? 0,
            params.slashing_penalty ?? 0,
        ], [this.coinType]);
    }
    async loadData() {
        const queueTypes = new Set([
            `${this.switchboardAddress}::oracle_queue::OracleQueue<${this.coinType}>`,
            `${this.switchboardAddress}::oracle_queue::OracleQueueData`,
            `${this.switchboardAddress}::oracle_queue::OracleQueueConfig`,
        ]);
        const datas = await this.client.getAccountResources({
            accountAddress: this.address,
        });
        const queueData = datas.filter((resource) => queueTypes.has(resource.type));
        // merge queue data
        const data = queueData.reduce((prev, curr) => ({ ...prev, ...curr.data }), {});
        return types.OracleQueue.fromMoveStruct(data);
    }
}
exports.OracleQueueAccount = OracleQueueAccount;
/**
 * Leases are kept in a LeaseManager resource on the same account that an Aggregator
 * exists on.
 */
class LeaseAccount {
    client;
    address;
    switchboardAddress;
    coinType;
    constructor(client, address /* aggregator account address */, switchboardAddress, coinType = DEFAULT_COINTYPE) {
        this.client = client;
        this.address = address;
        this.switchboardAddress = switchboardAddress;
        this.coinType = coinType;
    }
    /**
     * Initialize a LeaseAccount
     * @param client
     * @param account account that will be the authority of the LeaseAccount
     * @param params LeaseInitParams initialization params
     */
    static async init(client, account, params, switchboardAddress) {
        const leaseAccount = new LeaseAccount(client, params.aggregatorAddress, switchboardAddress, params.coinType);
        const tx = await sendAptosTx(client, account, `${switchboardAddress}::lease_init_action::run`, [
            params.aggregatorAddress,
            params.queueAddress,
            params.withdrawAuthority,
            params.initialAmount,
        ], [leaseAccount.coinType]);
        return [leaseAccount, tx];
    }
    /**
     * Extend a lease
     * @param params CrankPushParams
     */
    async extend(account, params) {
        return await sendAptosTx(this.client, account, `${this.switchboardAddress}::lease_extend_action::run`, [this.address, params.loadAmount], [this.coinType]);
    }
    /**
     * Extend a lease tx
     * @param params CrankPushParams
     */
    extendTx(sender, params) {
        return getAptosTx(this.client, sender.accountAddress.toString(), `${this.switchboardAddress}::lease_extend_action::run`, [this.address, params.loadAmount], [this.coinType]);
    }
    /**
     * Pop an aggregator off the Crank
     */
    async withdraw(account, params) {
        return await sendAptosTx(this.client, account, `${this.switchboardAddress}::lease_withdraw_action::run`, [[this.address, params.queueAddress, params.amount]], [this.coinType]);
    }
    /**
     * Pop an aggregator off the Crank
     */
    withdrawTx(sender, params) {
        return getAptosTx(this.client, sender.accountAddress.toString(), `${this.switchboardAddress}::lease_withdraw_action::run`, [this.address, params.queueAddress, params.amount], [this.coinType]);
    }
    /**
     * Set a lease authority
     * @param params CrankPushParams
     */
    async setAuthority(account, params) {
        return await sendAptosTx(this.client, account, `${this.switchboardAddress}::lease_set_authority_action::run`, [this.address, params.queueAddress, params.authority], [this.coinType]);
    }
    async loadData(queueAddress) {
        return await EscrowManager.fetchItem(this, queueAddress);
    }
}
exports.LeaseAccount = LeaseAccount;
class EscrowManager {
    client;
    address;
    switchboardAddress;
    coinType;
    constructor(client, address, switchboardAddress, coinType = DEFAULT_COINTYPE) {
        this.client = client;
        this.address = address;
        this.switchboardAddress = switchboardAddress;
        this.coinType = coinType;
    }
    async loadData() {
        const data = (await this.client.getAccountResource({
            accountAddress: this.address,
            resourceType: `${this.switchboardAddress}::escrow::EscrowManager<${this.coinType}>`,
        }));
        return types.EscrowManager.fromMoveStruct(data);
    }
    async fetchItem(queueAddress) {
        const escrowManagerState = await this.loadData();
        const item = await this.client.getTableItem({
            handle: escrowManagerState.escrows.handle.toString(),
            data: {
                key_type: `address`,
                value_type: `${this.switchboardAddress}::escrow::Escrow<${this.coinType}>`,
                key: queueAddress,
            },
        });
        return types.Escrow.fromMoveStruct(item);
    }
    static async fetchItem(account, queueAddress) {
        const escrowManager = new EscrowManager(account.client, account.address, account.switchboardAddress, account.coinType);
        return escrowManager.fetchItem(queueAddress);
    }
}
exports.EscrowManager = EscrowManager;
class OracleWallet {
    client;
    address;
    switchboardAddress;
    coinType;
    constructor(client, address, switchboardAddress, coinType = DEFAULT_COINTYPE) {
        this.client = client;
        this.address = address;
        this.switchboardAddress = switchboardAddress;
        this.coinType = coinType;
    }
    /**
     * Initialize an OracleWallet
     * @param client
     * @param account account that will be the authority of the OracleWallet
     * @param params OracleWalletInitParams initialization params
     */
    static async init(client, account, params, switchboardAddress) {
        const oracleWallet = new OracleWallet(client, account.accountAddress, switchboardAddress, params.coinType);
        const tx = await sendAptosTx(client, account, `${switchboardAddress}::oracle_wallet_init_action::run`, [params.oracleAddress, params.queueAddress], [oracleWallet.coinType]);
        return [oracleWallet, tx];
    }
    /**
     * Contributes to an oracle wallet
     * @param params OracleWalletContributeParams
     */
    async contribute(account, params) {
        return await sendAptosTx(this.client, account, `${this.switchboardAddress}::oracle_wallet_contribute_action::run`, [this.address, params.queueAddress, params.loadAmount], [this.coinType]);
    }
    /**
     * Withdraw from an OracleWallet
     */
    async withdraw(account, params) {
        return await sendAptosTx(this.client, account, `${this.switchboardAddress}::oracle_wallet_withdraw_action::run`, [[this.address, params.queueAddress, params.amount]], [this.coinType]);
    }
    async loadData(queueAddress) {
        const handle = (await this.client.getAccountResource({
            accountAddress: this.address,
            resourceType: `${this.switchboardAddress}::escrow::EscrowManager<${this.coinType}>`,
        })).escrows.handle;
        return await this.client.getTableItem({
            handle,
            data: {
                key_type: `address`,
                value_type: `${this.switchboardAddress}::escrow::Escrow<${this.coinType}>`,
                key: queueAddress,
            },
        });
    }
}
exports.OracleWallet = OracleWallet;
class Permission {
    client;
    switchboardAddress;
    constructor(client, switchboardAddress) {
        this.client = client;
        this.switchboardAddress = switchboardAddress;
    }
    /**
     * Initialize a Permission
     * @param client
     * @param account
     * @param params PermissionInitParams initialization params
     */
    static async init(client, account, params, switchboardAddress) {
        const tx = await (0, exports.sendRawAptosTx)(client, account, `${switchboardAddress}::permission_init_action::run`, [
            aptos_1.BCS.bcsToBytes(aptos_1.TxnBuilderTypes.AccountAddress.fromHex(params.authority.toString())),
            aptos_1.BCS.bcsToBytes(aptos_1.TxnBuilderTypes.AccountAddress.fromHex(params.granter.toString())),
            aptos_1.BCS.bcsToBytes(aptos_1.TxnBuilderTypes.AccountAddress.fromHex(params.grantee.toString())),
        ]);
        return [new Permission(client, switchboardAddress), tx];
    }
    /**
     * Set a Permission
     */
    async set(account, params) {
        const tx = await (0, exports.sendRawAptosTx)(this.client, account, `${this.switchboardAddress}::permission_set_action::run`, [
            aptos_1.BCS.bcsToBytes(aptos_1.TxnBuilderTypes.AccountAddress.fromHex(params.authority.toString())),
            aptos_1.BCS.bcsToBytes(aptos_1.TxnBuilderTypes.AccountAddress.fromHex(params.granter.toString())),
            aptos_1.BCS.bcsToBytes(aptos_1.TxnBuilderTypes.AccountAddress.fromHex(params.grantee.toString())),
            aptos_1.BCS.bcsSerializeUint64(params.permission),
            aptos_1.BCS.bcsSerializeBool(params.enable),
        ]);
        return tx;
    }
}
exports.Permission = Permission;
function safeDiv(number_, denominator, decimals = 20) {
    const oldDp = common_1.Big.DP;
    common_1.Big.DP = decimals;
    const result = number_.div(denominator);
    common_1.Big.DP = oldDp;
    return result;
}
async function createFeedTx(client, sender, params, switchboardAddress) {
    const seed = params.seed ? params.seed : ts_sdk_1.Account.generate().accountAddress;
    const resource_address = generateResourceAccountAddress(params.authority, bcsAddressToBytes(seed));
    if (params.jobs.length > 8) {
        throw new Error("Max Job limit exceeded. The create_feed_action can only create up to 8 jobs at a time.");
    }
    const { mantissa: vtMantissa, scale: vtScale } = AptosDecimal.fromBig(params.varianceThreshold ?? new common_1.Big(0));
    // enforce size 8 jobs array
    const jobs = params.jobs.length < 8
        ? [
            ...params.jobs,
            ...new Array(8 - params.jobs.length).fill({
                name: "",
                metadata: "",
                authority: "",
                data: "",
                weight: 1,
            }),
        ]
        : params.jobs;
    const aggregatorAccount = new AggregatorAccount(client, resource_address, switchboardAddress, params.coinType);
    const tx = await getAptosTx(client, sender.accountAddress.toString(), `${switchboardAddress}::create_feed_action::run`, [
        // authority will own everything
        params.authority,
        // aggregator
        params.name ?? "",
        params.metadata ?? "",
        params.queueAddress,
        params.batchSize,
        params.minOracleResults,
        params.minJobResults,
        params.minUpdateDelaySeconds,
        params.startAfter ?? 0,
        Number(vtMantissa),
        vtScale,
        params.forceReportPeriod ?? 0,
        params.expiration ?? 0,
        params.disableCrank ?? false,
        params.historySize ?? 0,
        params.readCharge ?? 0,
        params.rewardEscrow ? params.rewardEscrow : params.authority,
        params.readWhitelist ?? [],
        params.limitReadsToWhitelist ?? false,
        // lease
        params.initialLoadAmount,
        // jobs
        ...jobs.flatMap((jip) => {
            return [jip.name, jip.metadata, jip.data, jip.weight || 1];
        }),
        // crank
        params.crankAddress,
        // seed
        seed,
    ], [aggregatorAccount.coinType]);
    return [aggregatorAccount, tx];
}
exports.createFeedTx = createFeedTx;
// Create a feed with jobs, a lease, then optionally push the lease to the specified crank
async function createFeed(client, account, params, switchboardAddress) {
    const [aggregator, txn] = await createFeedTx(client, account, params, switchboardAddress);
    const tx = await sendSimpleAptosTx(client, account, txn);
    return [aggregator, tx];
}
exports.createFeed = createFeed;
// Create an oracle, oracle wallet, permisison, and set the heartbeat permission if user is the queue authority
async function createOracle(client, account, params, switchboardAddress) {
    const seed = params.seed ? params.seed : ts_sdk_1.Account.generate().accountAddress;
    const resource_address = generateResourceAccountAddress(account.accountAddress, bcsAddressToBytes(seed));
    const oracleAccount = new OracleAccount(client, resource_address, switchboardAddress, params.coinType);
    const tx = await sendAptosTx(client, account, `${switchboardAddress}::create_oracle_action::run`, [params.authority, params.name, params.metadata, params.queue, seed], [oracleAccount.coinType]);
    return [oracleAccount, tx];
}
exports.createOracle = createOracle;
function bcsAddressToBytes(hexStr) {
    return aptos_1.BCS.bcsToBytes(aptos_1.TxnBuilderTypes.AccountAddress.fromHex(hexStr.toString()));
}
exports.bcsAddressToBytes = bcsAddressToBytes;
function generateResourceAccountAddress(origin, seed) {
    const hash = SHA3.sha3_256.create();
    const userAddressBCS = bcsAddressToBytes(origin);
    hash.update(userAddressBCS);
    hash.update(new Uint8Array([...seed, 255]));
    return `0x${hash}`;
}
exports.generateResourceAccountAddress = generateResourceAccountAddress;
async function fetchAggregators(client, authority, switchboardAddress) {
    const handle = (await client.getAccountResource({
        accountAddress: switchboardAddress,
        resourceType: `${switchboardAddress}::switchboard::State`,
    })).data.aggregator_authorities.handle;
    const tableItems = await client.getTableItem({
        handle,
        data: {
            key_type: `address`,
            value_type: `vector<address>`,
            key: authority,
        },
    });
    return (await Promise.all(tableItems.map((aggregatorAddress) => new AggregatorAccount(client, aggregatorAddress, switchboardAddress).loadData()))).map((aggregator, i) => {
        aggregator.address = tableItems[i];
        return aggregator; // map addresses back to the aggregator object
    });
}
exports.fetchAggregators = fetchAggregators;
